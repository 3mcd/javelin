(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Javelin = {}));
}(this, (function (exports) { 'use strict';

    function assert(expression, message = "", type) {
        if (!expression) {
            throw new Error(type !== undefined
                ? `${errorMessagePrefixes[type]}: ${message}`
                : message);
        }
    }
    var ErrorType;
    (function (ErrorType) {
        ErrorType[ErrorType["Internal"] = 0] = "Internal";
    })(ErrorType || (ErrorType = {}));
    const errorMessagePrefixes = {
        [ErrorType.Internal]: "Internal Error",
    };

    function mutableRemoveUnordered(arr, element) {
        const length = arr.length;
        const index = arr.indexOf(element);
        if (index === -1) {
            return false;
        }
        const last = arr.pop();
        if (index < length - 1) {
            arr[index] = last;
        }
        return true;
    }
    function mutableEmpty(arr) {
        while (arr.length > 0)
            arr.pop();
    }
    function packSparseArray(array) {
        return array.reduce((a, x, i) => {
            a[i] = x;
            return a;
        }, {});
    }
    function unpackSparseArray(packedSparseArray) {
        const sparseArray = [];
        for (const index in packedSparseArray) {
            const i = parseInt(index, 10);
            if (!isNaN(i)) {
                sparseArray[i] = packedSparseArray[index];
            }
        }
        return sparseArray;
    }

    var SchemaKeyKind;
    (function (SchemaKeyKind) {
        SchemaKeyKind[SchemaKeyKind["Primitive"] = 0] = "Primitive";
        SchemaKeyKind[SchemaKeyKind["Array"] = 1] = "Array";
        SchemaKeyKind[SchemaKeyKind["Map"] = 2] = "Map";
    })(SchemaKeyKind || (SchemaKeyKind = {}));
    var DataTypeId;
    (function (DataTypeId) {
        DataTypeId["Number"] = "number";
        DataTypeId["Boolean"] = "boolean";
        DataTypeId["String"] = "string";
    })(DataTypeId || (DataTypeId = {}));
    const number = {
        __kind__: SchemaKeyKind.Primitive,
        __type__: DataTypeId.Number,
        create: () => 0,
        reset: (object, key) => (object[key] = 0),
    };
    const string = {
        __kind__: SchemaKeyKind.Primitive,
        __type__: DataTypeId.String,
        create: () => "",
        reset: (object, key) => (object[key] = 0),
    };
    const boolean = {
        __kind__: SchemaKeyKind.Primitive,
        __type__: DataTypeId.Boolean,
        create: () => false,
        reset: (object, key) => (object[key] = 0),
    };
    const arrayOf = (element) => ({
        __kind__: SchemaKeyKind.Array,
        __type__: element,
    });
    const mapOf = (element) => ({
        __kind__: SchemaKeyKind.Map,
        __type__: element,
    });
    const isPrimitiveType = (object) => "__kind__" in object &&
        object.__kind__ === SchemaKeyKind.Primitive;
    const isArrayType = (object) => "__kind__" in object && object.__kind__ === SchemaKeyKind.Array;
    const isMapType = (object) => "__kind__" in object && object.__kind__ === SchemaKeyKind.Map;
    var ModelNodeKind;
    (function (ModelNodeKind) {
        ModelNodeKind[ModelNodeKind["Primitive"] = 0] = "Primitive";
        ModelNodeKind[ModelNodeKind["Struct"] = 1] = "Struct";
        ModelNodeKind[ModelNodeKind["Array"] = 2] = "Array";
        ModelNodeKind[ModelNodeKind["Map"] = 3] = "Map";
    })(ModelNodeKind || (ModelNodeKind = {}));
    function assertIsModelNodeStructDescendant(node) {
        assert("key" in node, "", ErrorType.Internal);
    }
    const localeCompare = (a, b) => a.localeCompare(b);
    const insertNode = (target, type, ids, key) => {
        const id = ++ids;
        let kind;
        switch (type.__kind__) {
            case SchemaKeyKind.Array:
                kind = ModelNodeKind.Array;
                break;
            case SchemaKeyKind.Map:
                kind = ModelNodeKind.Map;
                break;
            case SchemaKeyKind.Primitive:
                kind = ModelNodeKind.Primitive;
                break;
            default:
                kind = ModelNodeKind.Struct;
                break;
        }
        const base = {
            id,
            lo: id,
            hi: -1,
            inCollection: target.inCollection ||
                target.kind === ModelNodeKind.Array ||
                target.kind === ModelNodeKind.Map,
            kind,
        };
        let node;
        if (isPrimitiveType(type)) {
            node = { ...base, kind: ModelNodeKind.Primitive, type };
        }
        else if (isArrayType(type)) {
            node = { ...base, kind: ModelNodeKind.Array };
            ids = insertNode(node, type.__type__, ids);
        }
        else if (isMapType(type)) {
            node = { ...base, kind: ModelNodeKind.Map };
            ids = insertNode(node, type.__type__, ids);
        }
        else {
            node = {
                ...base,
                kind: ModelNodeKind.Struct,
                edges: [],
                keys: {},
                idsByKey: {},
            };
            ids = collate(type, node, ids);
        }
        node.hi = ids;
        if (key) {
            node.key = key;
            assert(target.kind === ModelNodeKind.Struct, "expected target node to be struct", ErrorType.Internal);
            assertIsModelNodeStructDescendant(node);
            target.edges.push(node);
            target.keys[node.key] = node;
            target.idsByKey[node.key] = id;
        }
        else {
            assert(target.kind === ModelNodeKind.Array || target.kind === ModelNodeKind.Map, "expected target node to be collection", ErrorType.Internal);
            target.edge = node;
        }
        return ids;
    };
    const collate = (schema, target, ids = -1) => {
        const keys = Object.keys(schema).sort(localeCompare);
        for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            const value = schema[key];
            ids = insertNode(target, value, ids, key);
        }
        target.hi = ids;
        return ids;
    };
    const getModelRoot = () => ({
        edges: [],
        hi: Infinity,
        lo: -1,
        id: -1,
        idsByKey: {},
        inCollection: false,
        keys: {},
        kind: ModelNodeKind.Struct,
    });
    /**
     * createModel() produces a graph from a model and assigns each writable field
     * a unique integer id.
     *
     * @param config
     * @returns Model
     */
    const createModel = (config) => {
        const model = {};
        config.forEach((schema, typeId) => {
            const root = getModelRoot();
            collate(schema, root);
            model[typeId] = root;
        });
        return model;
    };

    function initialize(object, schema) {
        for (const prop in schema) {
            const value = schema[prop];
            if (isPrimitiveType(value)) {
                object[prop] = value.create();
            }
            else if (value.__kind__ === SchemaKeyKind.Array) {
                object[prop] = [];
            }
            else {
                object[prop] = initialize({}, value);
            }
        }
        return object;
    }
    function reset(component, schema) {
        for (const prop in schema) {
            const value = schema[prop];
            if (isPrimitiveType(value)) {
                value.reset(component, prop, undefined);
            }
            else if (isArrayType(value)) {
                mutableEmpty(value);
            }
            else {
                reset(component[prop], value);
            }
        }
        return component;
    }

    const createSignal = () => {
        const subscribers = [];
        const subscribe = (subscriber) => {
            subscribers.push(subscriber);
            return () => mutableRemoveUnordered(subscribers, subscriber);
        };
        const dispatch = (t, t2, t3) => {
            for (let i = 0; i < subscribers.length; i++) {
                subscribers[i](t, t2, t3);
            }
        };
        return {
            subscribe,
            dispatch,
        };
    };

    function createArchetypeState(options) {
        const snapshot = "snapshot" in options ? options.snapshot : null;
        const entities = snapshot ? Object.keys(snapshot.indices).map(Number) : [];
        const indices = snapshot ? unpackSparseArray(snapshot.indices) : [];
        const signature = ("signature" in options
            ? options.signature
            : options.snapshot.signature)
            .slice()
            .sort((a, b) => a - b);
        const table = (snapshot
            ? snapshot.table.map(column => column.slice())
            : signature.map(() => []));
        const signatureInverse = signature.reduce((a, x, i) => {
            a[x] = i;
            return a;
        }, []);
        return { entities, indices, signature, signatureInverse, table };
    }
    /**
     * Create an Archetype.
     *
     * @param signature Array of component types that make up the archetype
     * @param table  Initial component data
     */
    function createArchetype(options) {
        const { signature, signatureInverse, entities, indices, table, } = createArchetypeState(options);
        const inserted = createSignal();
        const removed = createSignal();
        function insert(entity, components) {
            for (let i = 0; i < components.length; i++) {
                const component = components[i];
                const componentTypeIndex = signatureInverse[component.__type__];
                table[componentTypeIndex].push(component);
            }
            indices[entity] = entities.push(entity) - 1;
            inserted.dispatch(entity);
        }
        function remove(entity) {
            const length = entities.length;
            const index = indices[entity];
            const head = entities.pop();
            delete indices[entity];
            if (index === length - 1) {
                for (const column of table)
                    column.pop();
            }
            else {
                // Move leading entity's components to removed index position
                for (const column of table) {
                    column[index] = column.pop();
                }
                // Move leading entity to removed index position
                entities[index] = head;
                // Update previously leading entity's index
                indices[head] = index;
            }
            removed.dispatch(entity);
        }
        return {
            entities,
            indices,
            insert,
            inserted,
            remove,
            removed,
            signature,
            signatureInverse,
            table,
        };
    }

    const UNSAFE_internals = {
        __MODEL__: {},
        __WORLDS__: [],
        __CURRENT_WORLD__: -1,
    };
    const UNSAFE_modelChanged = createSignal();
    const setModel = (model) => {
        UNSAFE_internals.__MODEL__ = model;
        UNSAFE_modelChanged.dispatch(model);
    };

    const $componentType = Symbol("javelin_component_type");

    function createStackPool(type, reset, size) {
        const heap = [];
        const allocate = () => {
            for (let i = 0; i < size; i++) {
                heap.push(type(pool));
            }
        };
        const retain = () => {
            if (!heap.length) {
                allocate();
            }
            return heap.pop();
        };
        const release = (obj) => {
            heap.push(reset(obj));
        };
        const pool = {
            allocate,
            retain,
            release,
        };
        return pool;
    }

    let nextComponentTypeId = 0;
    function createComponentBase(componentType) {
        return Object.defineProperties({}, {
            __type__: {
                value: componentType[$componentType],
                writable: false,
                enumerable: true,
            },
        });
    }
    function isComponentOf(component, componentTypeId) {
        return component.__type__ === componentTypeId[$componentType];
    }
    const componentTypePools = new Map();
    function createComponentPool(componentType, poolSize) {
        const componentPool = createStackPool(() => initialize(createComponentBase(componentType), componentType), component => reset(component, componentType), poolSize);
        return componentPool;
    }
    const modelConfig = new Map();
    const registerComponentType = (componentType, componentTypeId, poolSize = 1000) => {
        let type = componentType[$componentType];
        if (type !== undefined) {
            return type;
        }
        type = componentTypeId;
        if (type === undefined) {
            while (modelConfig.has(nextComponentTypeId)) {
                nextComponentTypeId++;
            }
            type = componentType[$componentType] = nextComponentTypeId;
        }
        else if (modelConfig.has(type)) {
            throw new Error("Failed to register component type: a component with same id is already registered");
        }
        componentTypePools.set(type, createComponentPool(componentType, poolSize));
        modelConfig.set(type, componentType);
        setModel(createModel(modelConfig));
        return type;
    };
    const component = (componentType) => {
        registerComponentType(componentType);
        return componentTypePools.get(componentType[$componentType]).retain();
    };

    function isPromise(object) {
        return typeof object === "object" && object !== null && "then" in object;
    }
    function createEffect(factory, options = { throw: false, global: false }) {
        const { global } = options;
        const systemEffectDataByWorldId = [];
        let previousTick;
        let previousWorld;
        let previousSystem;
        let currentWorld;
        let currentSystem;
        let cellCount = -1;
        return function effect(...args) {
            currentWorld = UNSAFE_internals.__CURRENT_WORLD__;
            const world = UNSAFE_internals.__WORLDS__[currentWorld];
            const currentTick = world.state.currentTick;
            currentSystem = global ? 0 : world.state.currentSystem;
            let currentWorldSystemEffectData = systemEffectDataByWorldId[currentWorld];
            if (systemEffectDataByWorldId[currentWorld] === undefined) {
                currentWorldSystemEffectData = systemEffectDataByWorldId[currentWorld] = [];
            }
            let currentSystemEffect = currentWorldSystemEffectData[currentSystem];
            if (currentSystemEffect === undefined) {
                currentSystemEffect = currentWorldSystemEffectData[currentSystem] = {
                    cells: [],
                    cellCount: -1,
                };
            }
            if (global === true ||
                (previousWorld !== currentWorld && previousWorld !== undefined)) {
                cellCount = 0;
            }
            else if (previousSystem !== undefined &&
                (previousTick !== currentTick || previousSystem !== currentSystem)) {
                let previousSystemEffectData = currentWorldSystemEffectData[previousSystem];
                if (previousSystemEffectData.cellCount !== -1 &&
                    previousSystemEffectData.cellCount !== cellCount) {
                    throw new Error(`Failed to execute effect: encountered too ${previousSystemEffectData.cellCount > cellCount ? "few" : "many"} effects this tick`);
                }
                previousSystemEffectData.cellCount = cellCount;
                cellCount = 0;
            }
            else {
                cellCount++;
            }
            let cell = currentSystemEffect.cells[cellCount];
            if (!cell) {
                cell = currentSystemEffect.cells[cellCount] = {
                    executor: factory(world),
                    lockGlobal: false,
                    lockAsync: false,
                    lockGlobalTick: -1,
                    state: null,
                };
            }
            if (global) {
                if (cell.lockGlobalTick !== world.state.currentTick) {
                    cell.lockGlobal = false;
                    cell.lockGlobalTick = world.state.currentTick;
                }
                else {
                    cell.lockGlobal = true;
                }
            }
            if (cell.lockGlobal || cell.lockAsync) {
                return cell.state;
            }
            const result = cell.executor(...args);
            if (isPromise(result)) {
                cell.lockAsync = true;
                result
                    .then(result => (cell.state = result))
                    .catch(error => console.error(`Uncaught error in effect: ${error.message}`, error))
                    .then(() => (cell.lockAsync = false));
            }
            else {
                cell.state = result;
            }
            previousTick = currentTick;
            previousWorld = currentWorld;
            previousSystem = currentSystem;
            return cell.state;
        };
    }

    const effRef = createEffect(() => {
        let initial = true;
        const api = { value: null };
        return function effRef(initialValue) {
            if (initial) {
                api.value = initialValue;
                initial = false;
            }
            return api;
        };
    });

    const effTimer = createEffect(() => {
        let state = 0;
        let timer;
        return function effTimer(duration, invalidate = false) {
            if (invalidate) {
                state = 0;
                clearTimeout(timer);
            }
            if (state === 0) {
                state = 1;
                timer = setTimeout(() => {
                    state = 2;
                }, duration);
            }
            return state === 2;
        };
    });

    const effInterval = createEffect(() => function effInterval(t) {
        const invalidate = effRef(false);
        const done = effTimer(t, invalidate.value);
        invalidate.value = done;
        return done;
    });

    const typeIsSuperset = (right, left) => {
        let i = 0;
        let j = 0;
        if (right.length < left.length) {
            return false;
        }
        while (i < right.length && j < left.length) {
            if (right[i] < left[j]) {
                i++;
            }
            else if (right[i] === left[j]) {
                i++;
                j++;
            }
            else {
                return false;
            }
        }
        return j === left.length;
    };

    const queryMatchesArchetype = (query, archetype) => typeIsSuperset(archetype.signature, query.signature) &&
        archetype.signature.every(c => !query.filters.not.has(c));
    /**
     * Create a query that can be used to iterate over entities that match a
     * provided component type selector. Maintains an automatically-updated
     * cache of archetypes, and can be used across multiple worlds.
     * @param selector Query selector
     * @returns Query
     * @example
     * const burning = createQuery(Player, Burn)
     * burning.forEach((entity, [player, burn]) => {
     *   player.health -= burn.damage
     * })
     */
    function createQuery(...selector) {
        const length = selector.length;
        const layout = selector.map(componentType => registerComponentType(componentType));
        const filters = {
            not: new Set(),
        };
        const signature = layout.slice().sort((a, b) => a - b);
        const recordsByWorldId = [];
        const maybeRegisterArchetype = (archetype, records) => {
            if (queryMatchesArchetype(query, archetype)) {
                const columns = layout.map(componentTypeId => archetype.table[archetype.signature.indexOf(componentTypeId)]);
                records.push([archetype.entities, columns]);
            }
        };
        const registerWorld = (worldId) => {
            const world = UNSAFE_internals.__WORLDS__[worldId];
            const records = [];
            recordsByWorldId[worldId] = records;
            world.storage.archetypes.forEach(archetype => maybeRegisterArchetype(archetype, records));
            world.storage.archetypeCreated.subscribe(archetype => maybeRegisterArchetype(archetype, records));
            return records;
        };
        const pool = createStackPool(() => [], components => {
            mutableEmpty(components);
            return components;
        }, 1000);
        const forEach = (iteratee) => {
            const records = recordsByWorldId[UNSAFE_internals.__CURRENT_WORLD__] ||
                registerWorld(UNSAFE_internals.__CURRENT_WORLD__);
            const components = pool.retain();
            for (let i = 0; i < records.length; i++) {
                const [entities, columns] = records[i];
                for (let j = 0; j < entities.length; j++) {
                    for (let k = 0; k < length; k++) {
                        components[k] = columns[k][j];
                    }
                    iteratee(entities[j], components);
                }
            }
            pool.release(components);
        };
        const query = forEach;
        query.layout = layout;
        query.signature = signature;
        query.filters = filters;
        query.not = (...selector) => {
            for (let i = 0; i < selector.length; i++) {
                filters.not.add(selector[i][$componentType]);
            }
            return query;
        };
        query[Symbol.iterator] = () => {
            return (recordsByWorldId[UNSAFE_internals.__CURRENT_WORLD__] ||
                registerWorld(UNSAFE_internals.__CURRENT_WORLD__))[Symbol.iterator]();
        };
        return query;
    }

    /**
     * Detect when an entity begins matching, or no longer matches, a query.
     *
     * @param query
     * @example
     * effMonitor(
     *   bodies,
     *   e => console.log(`${e} matches bodies`),
     *   e => console.log(`${e} no longer matches bodies`),
     * )
     */
    const effMonitor = createEffect(world => {
        const { storage: { entityRelocated }, } = world;
        let stagedEnter = [];
        let stagedExit = [];
        let readyEnter = [];
        let readyExit = [];
        let _query = null;
        const register = (query) => {
            _query = query;
            mutableEmpty(stagedEnter);
            mutableEmpty(stagedExit);
            mutableEmpty(readyEnter);
            mutableEmpty(readyExit);
            for (const [entities] of query) {
                for (let i = 0; i < entities.length; i++) {
                    stagedEnter.push(entities[i]);
                }
            }
        };
        entityRelocated.subscribe((entity, prev, next) => {
            if (_query === null) {
                return;
            }
            if (queryMatchesArchetype(_query, next)) {
                stagedEnter.push(entity);
            }
            else if (queryMatchesArchetype(_query, prev)) {
                stagedExit.push(entity);
            }
        });
        return function effMonitor(query, onEnter, onExit) {
            if (_query !== query) {
                register(query);
            }
            let entity;
            mutableEmpty(readyEnter);
            mutableEmpty(readyExit);
            while ((entity = stagedEnter.pop()) !== undefined) {
                readyEnter.push(entity);
            }
            while ((entity = stagedExit.pop()) !== undefined) {
                readyExit.push(entity);
            }
            if (onEnter !== undefined) {
                for (let i = 0; i < readyEnter.length; i++) {
                    onEnter(readyEnter[i]);
                }
            }
            if (onExit !== undefined) {
                for (let i = 0; i < readyExit.length; i++) {
                    onExit(readyExit[i]);
                }
            }
        };
    });

    const pairPool = createStackPool(() => [-1, null], event => {
        event[0] = -1;
        event[1] = null;
        return event;
    }, 1000);
    /**
     * Get components of a given type that were attached or detached during the
     * effect's last execution.
     *
     * @example
     * effTrigger(
     *   Body,
     *   (e, body) => console.log(`${e}'s Body was attached last tick`),
     *   (e, body) => console.log(`${e}'s Body was detached last tick`),
     * )
     */
    const effTrigger = createEffect(world => {
        const { storage: { archetypes }, } = world;
        const entities = new Set();
        const stagedEnter = [];
        const stagedExit = [];
        const readyEnter = [];
        const readyExit = [];
        let _componentType;
        let _componentTypeId;
        const push = (entity, component, target) => {
            const pair = pairPool.retain();
            pair[0] = entity;
            pair[1] = component;
            target.push(pair);
            entities.add(entity);
        };
        const register = (componentType) => {
            for (let i = 0; i < archetypes.length; i++) {
                const { table, entities, signatureInverse } = archetypes[i];
                const index = signatureInverse[componentType[$componentType]];
                if (index !== undefined) {
                    const column = table[index];
                    for (let i = 0; i < entities.length; i++) {
                        push(entities[i], column[i], stagedEnter);
                    }
                }
            }
            _componentType = componentType;
            _componentTypeId = componentType[$componentType];
        };
        world.attached.subscribe((e, components) => {
            for (let i = 0; i < components.length; i++) {
                const component = components[i];
                if (component.__type__ === _componentTypeId) {
                    push(e, component, stagedEnter);
                }
            }
        });
        world.detached.subscribe((e, components) => {
            for (let i = 0; i < components.length; i++) {
                const component = components[i];
                if (component.__type__ === _componentTypeId) {
                    push(e, component, stagedExit);
                }
            }
        });
        return function effTrigger(componentType, onEnter, onExit) {
            if (componentType !== _componentType) {
                register(componentType);
            }
            let rEnter;
            while ((rEnter = readyEnter.pop())) {
                pairPool.release(rEnter);
            }
            let rExit;
            while ((rExit = readyExit.pop())) {
                pairPool.release(rExit);
            }
            let sEnter;
            while ((sEnter = stagedEnter.pop())) {
                readyEnter.push(sEnter);
            }
            let sExit;
            while ((sExit = stagedExit.pop())) {
                readyExit.push(sExit);
            }
            entities.clear();
            if (onEnter) {
                for (let i = 0; i < readyEnter.length; i++) {
                    const [entity, component] = readyEnter[i];
                    onEnter(entity, component);
                }
            }
            if (onExit) {
                for (let i = 0; i < readyExit.length; i++) {
                    const [entity, component] = readyExit[i];
                    onExit(entity, component);
                }
            }
        };
    });

    const arrayOpPool = createStackPool(() => ({
        method: -1,
        record: null,
        values: [],
    }), op => {
        op.method = -1;
        op.record = null;
        mutableEmpty(op.values);
        return op;
    }, 10000);
    (function (MutArrayMethod) {
        MutArrayMethod[MutArrayMethod["Pop"] = 0] = "Pop";
        MutArrayMethod[MutArrayMethod["Push"] = 1] = "Push";
        MutArrayMethod[MutArrayMethod["Shift"] = 2] = "Shift";
        MutArrayMethod[MutArrayMethod["Unshift"] = 3] = "Unshift";
        MutArrayMethod[MutArrayMethod["Splice"] = 4] = "Splice";
    })(exports.MutArrayMethod || (exports.MutArrayMethod = {}));
    const PATH_DELIMITER = ".";
    const recordLookup = {};
    const createObserver = () => {
        let cache = new Map();
        const getRecord = (component, path) => {
            const { __type__: type } = component;
            const root = UNSAFE_internals.__MODEL__[type];
            let records = recordLookup[type];
            if (records === undefined) {
                records = recordLookup[type] = {};
            }
            let record = records[path];
            if (record === undefined) {
                let node = root;
                const traverse = [];
                const split = path.split(PATH_DELIMITER);
                for (let i = 0; i < split.length; i++) {
                    const sub = split[i];
                    switch (node.kind) {
                        case ModelNodeKind.Array:
                        case ModelNodeKind.Map:
                            node = node.edge;
                            traverse.push(sub);
                            break;
                        case ModelNodeKind.Struct:
                            node = node.keys[sub];
                            break;
                    }
                }
                records[path] = record = { traverse, path, split, field: node.id };
            }
            return record;
        };
        const getChanges = (component) => {
            let changes = cache.get(component);
            if (changes === undefined) {
                changes = { object: {}, objectCount: 0, array: [], arrayCount: 0 };
                cache.set(component, changes);
            }
            return changes;
        };
        const track = (component, path, value) => {
            const record = getRecord(component, path);
            const changes = getChanges(component);
            const change = changes.object[path];
            if (change) {
                if (change.noop) {
                    change.noop = false;
                    changes.objectCount++;
                }
                change.value = value;
            }
            else {
                changes.objectCount++;
                changes.object[path] = { record, value, noop: false };
            }
        };
        function trackPop(component, path) {
            const record = getRecord(component, path);
            const changes = getChanges(component);
            const arrayOp = arrayOpPool.retain();
            arrayOp.record = record;
            arrayOp.method = exports.MutArrayMethod.Pop;
            changes.arrayCount++;
            changes.array.push(arrayOp);
        }
        function trackPush(component, path) {
            const record = getRecord(component, path);
            const changes = getChanges(component);
            const arrayOp = arrayOpPool.retain();
            arrayOp.record = record;
            arrayOp.method = exports.MutArrayMethod.Push;
            for (let i = 2; i < arguments.length; i++) {
                arrayOp.values.push(arguments[i]);
            }
            changes.arrayCount++;
            changes.array.push(arrayOp);
        }
        function trackShift(component, path) {
            const record = getRecord(component, path);
            const changes = getChanges(component);
            const arrayOp = arrayOpPool.retain();
            arrayOp.record = record;
            arrayOp.method = exports.MutArrayMethod.Shift;
            changes.arrayCount++;
            changes.array.push(arrayOp);
        }
        function trackUnshift(component, path) {
            const record = getRecord(component, path);
            const changes = getChanges(component);
            const arrayOp = arrayOpPool.retain();
            arrayOp.record = record;
            arrayOp.method = exports.MutArrayMethod.Unshift;
            for (let i = 2; i < arguments.length; i++) {
                arrayOp.values.push(arguments[i]);
            }
            changes.arrayCount++;
            changes.array.push(arrayOp);
        }
        function trackSplice(component, path, index, remove) {
            const record = getRecord(component, path);
            const changes = getChanges(component);
            const arrayOp = arrayOpPool.retain();
            arrayOp.record = record;
            arrayOp.method = exports.MutArrayMethod.Splice;
            arrayOp.index = index;
            arrayOp.remove = remove;
            for (let i = 2; i < arguments.length; i++) {
                arrayOp.values.push(arguments[i]);
            }
            changes.arrayCount++;
            changes.array.push(arrayOp);
        }
        const emptyChanges = (changes) => {
            const { array, object } = changes;
            let arrayOp;
            while ((arrayOp = array.pop())) {
                arrayOpPool.release(arrayOp);
            }
            for (const prop in object) {
                object[prop].noop = true;
            }
            changes.objectCount = 0;
            changes.arrayCount = 0;
        };
        const empty = (component) => {
            const changes = cache.get(component);
            if (changes !== undefined) {
                emptyChanges(changes);
            }
        };
        const clear = () => cache.forEach(emptyChanges);
        const reset = (component) => {
            const changes = cache.get(component);
            if (changes !== undefined) {
                emptyChanges(changes);
            }
            cache.delete(component);
        };
        const changesOf = (component) => cache.get(component) || null;
        return {
            track,
            trackPop,
            trackPush,
            trackShift,
            trackUnshift,
            trackSplice,
            changesOf,
            empty,
            clear,
            reset,
        };
    };

    const effObserve = createEffect(world => {
        const observer = createObserver();
        world.detached.subscribe((e, components) => components.forEach(observer.reset));
        return function effObserve(clear = true) {
            if (clear) {
                observer.clear();
            }
            return observer;
        };
    });

    const effRequest = createEffect(() => {
        let state = { response: null, error: null, done: false };
        let fetching = false;
        let previousUrl;
        let abortController = new window.AbortController();
        return function effRequest(url, options, invalidate = previousUrl !== undefined && url !== previousUrl) {
            if (url === null || invalidate) {
                abortController.abort();
                abortController = new AbortController();
            }
            if (url === null) {
                return state;
            }
            if (invalidate) {
                state = { response: state.response, error: null, done: false };
            }
            if (state.done) {
                return state;
            }
            if (!fetching) {
                fetching = true;
                previousUrl = url;
                fetch(url, { ...options, signal: abortController.signal })
                    .then(response => {
                    state = { response, error: null, done: true };
                })
                    .catch(error => {
                    state = { response: state.response, error, done: true };
                })
                    .then(() => {
                    fetching = false;
                });
            }
            return state;
        };
    });

    const effJson = createEffect(() => {
        let response;
        return function effJson(...args) {
            const previousResponse = effRef(null);
            const result = effRequest(...args);
            if (result.response && result.response !== previousResponse.value) {
                result.response.json().then((json) => {
                    response = json;
                });
                previousResponse.value = result.response;
            }
            return { ...result, response: response || null };
        };
    });

    function createStorage(options = {}) {
        const archetypeCreated = createSignal();
        const entityRelocated = createSignal();
        const archetypes = options.snapshot
            ? options.snapshot.archetypes.map(snapshot => createArchetype({ snapshot }))
            : [];
        // Array where the index corresponds to an entity and the value corresponds
        // to the index of the entity's archetype within the `archetypes` array. When
        // mutating or reading components, we always assume the location is valid
        // since it is kept in sync with the entity's archetype via the `create`,
        // `insert`, and `remove` methods.
        const archetypeIndicesByEntity = [];
        /**
         * Locate an archetype which matches the signature of a collection of
         * components.
         * @param components Components that archetype would contain
         */
        function findArchetype(components) {
            const componentsLength = components.length;
            for (let i = 0; i < archetypes.length; i++) {
                const archetype = archetypes[i];
                const { signature } = archetype;
                // Verify archetype has same number of components as predicate.
                if (signature.length !== componentsLength) {
                    continue;
                }
                let match = true;
                for (let j = 0; j < componentsLength; j++) {
                    if (signature.indexOf(components[j].__type__) === -1) {
                        match = false;
                        break;
                    }
                }
                if (match) {
                    return archetype;
                }
            }
            return null;
        }
        /**
         * Locate or create an archetype for a collection of components.
         * @param components Components that archetype would contain
         */
        function findOrCreateArchetype(components) {
            let archetype = findArchetype(components);
            if (!archetype) {
                archetype = createArchetype({
                    signature: components.map(c => c.__type__),
                });
                archetypes.push(archetype);
                archetypeCreated.dispatch(archetype);
            }
            return archetype;
        }
        function create(entity, components) {
            const archetype = findOrCreateArchetype(components);
            archetype.insert(entity, components);
            archetypeIndicesByEntity[entity] = archetypes.indexOf(archetype);
            return entity;
        }
        function getEntityArchetype(entity) {
            const location = archetypeIndicesByEntity[entity];
            if (location === undefined) {
                throw new Error(`Failed to locate entity. Entity does not exist.`);
            }
            if (location === null) {
                throw new Error(`Failed to locate entity. Entity has been removed.`);
            }
            return archetypes[location];
        }
        function relocate(source, entity, components) {
            source.remove(entity);
            const destination = findOrCreateArchetype(components);
            destination.insert(entity, components);
            archetypeIndicesByEntity[entity] = archetypes.indexOf(destination);
            entityRelocated.dispatch(entity, source, destination);
        }
        function insert(entity, components) {
            const source = getEntityArchetype(entity);
            const entityIndex = source.indices[entity];
            let destinationComponents = components.slice();
            for (let i = 0; i < source.signature.length; i++) {
                const componentTypeId = source.signature[i];
                if (components.find(c => c.__type__ === componentTypeId)) {
                    throw new Error(`Failed to attach component with type ${componentTypeId}: entity already has component of type`);
                }
                destinationComponents.push(source.table[i][entityIndex]);
            }
            relocate(source, entity, destinationComponents);
        }
        function remove(entity, components) {
            const typesToRemove = components.map(component => component.__type__);
            removeByTypeIds(entity, typesToRemove);
        }
        function removeByTypeIds(entity, componentTypeIds) {
            const source = getEntityArchetype(entity);
            const entityIndex = source.indices[entity];
            let destinationComponents = [];
            for (let i = 0; i < source.signature.length; i++) {
                const type = source.signature[i];
                const component = source.table[i][entityIndex];
                if (!componentTypeIds.includes(type)) {
                    destinationComponents.push(component);
                }
            }
            relocate(source, entity, destinationComponents);
        }
        function destroy(entity) {
            remove(entity, getEntityComponents(entity));
            archetypeIndicesByEntity[entity] = null;
        }
        const tmpComponentsToInsert = [];
        function upsert(entity, components) {
            const archetype = getEntityArchetype(entity);
            const entityIndex = archetype.indices[entity];
            mutableEmpty(tmpComponentsToInsert);
            for (let i = 0; i < components.length; i++) {
                const component = components[i];
                const column = archetype.signatureInverse[component.__type__];
                if (column === undefined) {
                    // Entity component makeup does not match patch component, insert the new
                    // component.
                    tmpComponentsToInsert.push(component);
                }
                else {
                    // Apply patch to component.
                    Object.assign(archetype.table[column][entityIndex], component);
                }
            }
            if (tmpComponentsToInsert.length > 0) {
                insert(entity, tmpComponentsToInsert);
            }
        }
        function hasComponent(entity, componentType) {
            const archetype = getEntityArchetype(entity);
            return archetype.signature.includes(componentType[$componentType]);
        }
        function findComponent(entity, componentType) {
            return findComponentByComponentTypeId(entity, componentType[$componentType]);
        }
        function findComponentByComponentTypeId(entity, componentTypeId) {
            const archetype = getEntityArchetype(entity);
            const column = archetype.signatureInverse[componentTypeId];
            if (column === undefined) {
                return null;
            }
            const entityIndex = archetype.indices[entity];
            return archetype.table[column][entityIndex];
        }
        function getEntityComponents(entity) {
            const archetype = getEntityArchetype(entity);
            const entityIndex = archetype.indices[entity];
            const result = [];
            for (let i = 0; i < archetype.table.length; i++) {
                result.push(archetype.table[i][entityIndex]);
            }
            return result;
        }
        function clear() {
            mutableEmpty(archetypes);
            mutableEmpty(archetypeIndicesByEntity);
        }
        function snapshot() {
            return {
                archetypes: archetypes.map(archetype => ({
                    signature: archetype.signature.slice(),
                    table: archetype.table.map(column => column.map(component => ({ ...component }))),
                    indices: packSparseArray(archetype.indices),
                })),
            };
        }
        return {
            archetypeCreated,
            archetypes,
            clear,
            create,
            destroy,
            entityRelocated,
            findComponent,
            findComponentByComponentTypeId,
            getEntityComponents,
            hasComponent,
            insert,
            remove,
            removeByTypeIds,
            snapshot,
            upsert,
        };
    }

    /**
     * The utility method used to create a topic, consumes a type parameter
     * and a name and returns an object that conforms to the topic type
     */
    const createTopic = () => {
        const staged = [];
        const ready = [];
        const push = (event) => staged.push(event);
        const pushImmediate = (event) => ready.push(event);
        const flush = () => {
            mutableEmpty(ready);
            const len = staged.length;
            for (let i = len - 1; i >= 0; i--) {
                ready[i] = staged.pop();
            }
        };
        const clear = () => {
            mutableEmpty(staged);
            mutableEmpty(ready);
        };
        return {
            *[Symbol.iterator]() {
                for (let i = 0; i < ready.length; i++) {
                    yield ready[i];
                }
            },
            push,
            pushImmediate,
            flush,
            clear,
        };
    };

    (function (WorldOpType) {
        WorldOpType[WorldOpType["Spawn"] = 0] = "Spawn";
        WorldOpType[WorldOpType["Attach"] = 1] = "Attach";
        WorldOpType[WorldOpType["Detach"] = 2] = "Detach";
        WorldOpType[WorldOpType["Mutate"] = 3] = "Mutate";
        WorldOpType[WorldOpType["Destroy"] = 4] = "Destroy";
    })(exports.WorldOpType || (exports.WorldOpType = {}));

    function getInitialWorldState() {
        return {
            currentTickData: null,
            currentTick: 0,
            currentSystem: 0,
        };
    }
    function createWorld(options = {}) {
        var _a, _b;
        const { topics = [] } = options;
        const systems = [];
        const worldOps = [];
        const worldOpsPrevious = [];
        const worldOpPool = createStackPool(() => [], op => {
            mutableEmpty(op);
            return op;
        }, 1000);
        const attached = createSignal();
        const detached = createSignal();
        const spawned = createSignal();
        const destroyed = createSignal();
        const destroying = new Set();
        const storage = createStorage({ snapshot: (_a = options.snapshot) === null || _a === void 0 ? void 0 : _a.storage });
        let state = getInitialWorldState();
        let prevEntity = 0;
        let nextSystem = 0;
        (_b = options.systems) === null || _b === void 0 ? void 0 : _b.forEach(addSystem);
        detached.subscribe((entity, components) => components.forEach(maybeReleaseComponent));
        function createWorldOp(...args) {
            const worldOp = worldOpPool.retain();
            for (let i = 0; i < args.length; i++) {
                worldOp[i] = args[i];
            }
            return worldOp;
        }
        function internalSpawn(entity) {
            storage.create(entity, []);
            spawned.dispatch(entity);
        }
        function internalAttach(entity, components) {
            storage.insert(entity, components);
            attached.dispatch(entity, components);
        }
        function internalDetach(entity, components) {
            storage.remove(entity, components);
            detached.dispatch(entity, components);
        }
        function internalDestroy(entity) {
            storage.destroy(entity);
            destroyed.dispatch(entity);
        }
        function applySpawnOp(op) {
            const [, entity] = op;
            internalSpawn(entity);
        }
        function applyAttachOp(op) {
            const [, entity, components] = op;
            internalAttach(entity, components);
        }
        function applyDetachOp(op) {
            const [, entity, components] = op;
            internalDetach(entity, components);
        }
        function applyDestroyOp(op) {
            const [, entity] = op;
            internalDestroy(entity);
        }
        function applyWorldOp(worldOp, record = true) {
            if (record === true) {
                worldOpsPrevious.push(worldOp);
            }
            switch (worldOp[0]) {
                case exports.WorldOpType.Spawn:
                    return applySpawnOp(worldOp);
                case exports.WorldOpType.Attach:
                    return applyAttachOp(worldOp);
                case exports.WorldOpType.Detach:
                    return applyDetachOp(worldOp);
                case exports.WorldOpType.Destroy:
                    return applyDestroyOp(worldOp);
            }
        }
        function maybeReleaseComponent(component) {
            const pool = componentTypePools.get(component.__type__);
            if (pool) {
                pool.release(component);
            }
        }
        function tick(data) {
            UNSAFE_internals.__CURRENT_WORLD__ = id;
            state.currentTickData = data;
            // Clear world op history
            while (worldOpsPrevious.length > 0) {
                worldOpPool.release(worldOpsPrevious.pop());
            }
            for (let i = 0; i < worldOps.length; i++) {
                applyWorldOp(worldOps[i]);
            }
            mutableEmpty(worldOps);
            for (let i = 0; i < topics.length; i++) {
                topics[i].flush();
            }
            // Execute systems
            for (let i = 0; i < systems.length; i++) {
                const system = systems[i];
                world.state.currentSystem = system.__JAVELIN_SYSTEM_ID__;
                system(world);
            }
            destroying.clear();
            state.currentTick++;
        }
        function addSystem(system) {
            systems.push(system);
            system.__JAVELIN_SYSTEM_ID__ = nextSystem;
        }
        function removeSystem(system) {
            const index = systems.indexOf(system);
            if (index > -1) {
                systems.splice(index, 1);
            }
        }
        function addTopic(topic) {
            topics.push(topic);
        }
        function removeTopic(topic) {
            const index = topics.indexOf(topic);
            if (index > -1) {
                topics.splice(index, 1);
            }
        }
        function spawn(...components) {
            const entity = prevEntity++;
            worldOps.push(createWorldOp(exports.WorldOpType.Spawn, entity), createWorldOp(exports.WorldOpType.Attach, entity, components));
            return entity;
        }
        function attach(entity, ...components) {
            worldOps.push(createWorldOp(exports.WorldOpType.Attach, entity, components));
        }
        function detach(entity, ...components) {
            if (components.length === 0) {
                return;
            }
            if ($componentType in components[0]) {
                components = components.map(ct => get(entity, ct));
            }
            worldOps.push(createWorldOp(exports.WorldOpType.Detach, entity, components));
        }
        function destroy(entity) {
            if (destroying.has(entity)) {
                return;
            }
            const components = storage.getEntityComponents(entity);
            worldOps.push(createWorldOp(exports.WorldOpType.Detach, entity, components), createWorldOp(exports.WorldOpType.Destroy, entity));
            destroying.add(entity);
        }
        function applyOps(ops) {
            for (let i = 0; i < ops.length; i++) {
                applyWorldOp(ops[i], false);
            }
        }
        function has(entity, componentType) {
            registerComponentType(componentType);
            return storage.hasComponent(entity, componentType);
        }
        function get(entity, componentType) {
            registerComponentType(componentType);
            const component = storage.findComponent(entity, componentType);
            if (component === null) {
                throw new Error("Component not found");
            }
            return component;
        }
        function tryGet(entity, componentType) {
            registerComponentType(componentType);
            return storage.findComponent(entity, componentType);
        }
        function reserve() {
            return ++prevEntity;
        }
        function reset() {
            mutableEmpty(worldOps);
            mutableEmpty(worldOpsPrevious);
            mutableEmpty(systems);
            destroying.clear();
            state = getInitialWorldState();
            prevEntity = 0;
            while (worldOps.length > 0) {
                worldOpPool.release(worldOps.pop());
            }
            while (worldOpsPrevious.length > 0) {
                worldOpPool.release(worldOpsPrevious.pop());
            }
            // release components
            for (let i = 0; i < storage.archetypes.length; i++) {
                const archetype = storage.archetypes[i];
                for (let j = 0; j < archetype.signature.length; j++) {
                    const column = archetype.table[j];
                    const componentPool = componentTypePools.get(archetype.signature[j]);
                    for (let k = 0; k < column.length; k++) {
                        const component = column[k];
                        componentPool === null || componentPool === void 0 ? void 0 : componentPool.release(component);
                    }
                }
            }
            storage.clear();
        }
        function snapshot() {
            return {
                storage: storage.snapshot(),
            };
        }
        const world = {
            addSystem,
            addTopic,
            applyOps,
            attach,
            destroy,
            detach,
            get,
            has,
            id: -1,
            ops: worldOpsPrevious,
            removeSystem,
            removeTopic,
            reserve,
            reset,
            snapshot,
            spawn,
            state,
            storage,
            tick,
            tryGet,
            // signals
            attached,
            detached,
            spawned,
            destroyed,
            // internal
            internalSpawn,
            internalAttach,
            internalDetach,
            internalDestroy,
        };
        let id = (world.id = UNSAFE_internals.__WORLDS__.push(world) - 1);
        return world;
    }

    exports.$componentType = $componentType;
    exports.UNSAFE_internals = UNSAFE_internals;
    exports.UNSAFE_modelChanged = UNSAFE_modelChanged;
    exports.arrayOf = arrayOf;
    exports.boolean = boolean;
    exports.component = component;
    exports.componentTypePools = componentTypePools;
    exports.createArchetype = createArchetype;
    exports.createComponentBase = createComponentBase;
    exports.createComponentPool = createComponentPool;
    exports.createEffect = createEffect;
    exports.createObserver = createObserver;
    exports.createQuery = createQuery;
    exports.createStorage = createStorage;
    exports.createTopic = createTopic;
    exports.createWorld = createWorld;
    exports.effInterval = effInterval;
    exports.effJson = effJson;
    exports.effMonitor = effMonitor;
    exports.effObserve = effObserve;
    exports.effRef = effRef;
    exports.effRequest = effRequest;
    exports.effTimer = effTimer;
    exports.effTrigger = effTrigger;
    exports.isComponentOf = isComponentOf;
    exports.mapOf = mapOf;
    exports.number = number;
    exports.queryMatchesArchetype = queryMatchesArchetype;
    exports.registerComponentType = registerComponentType;
    exports.setModel = setModel;
    exports.string = string;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
