!(function (e, t) {
  "object" == typeof exports && "undefined" != typeof module
    ? t(exports)
    : "function" == typeof define && define.amd
    ? define(["exports"], t)
    : t(
        ((e =
          "undefined" != typeof globalThis ? globalThis : e || self).Javelin =
          {}),
      )
})(this, function (e) {
  "use strict"
  function t(e, t = "", n) {
    if (!e) throw new Error(void 0 !== n ? `${r[n]}: ${t}` : t)
  }
  var n
  !(function (e) {
    ;(e[(e.Internal = 0)] = "Internal"), (e[(e.Query = 1)] = "Query")
  })(n || (n = {}))
  const r = { [n.Internal]: "Internal Error", [n.Query]: "Query Error" },
    o = Symbol("javelin_field_kind"),
    s = Symbol("javelin_model_flat")
  var c
  function l(e) {
    for (; e.length > 0; ) e.pop()
    return e
  }
  !(function (e) {
    ;(e[(e.Number = 0)] = "Number"),
      (e[(e.String = 1)] = "String"),
      (e[(e.Boolean = 2)] = "Boolean"),
      (e[(e.Array = 3)] = "Array"),
      (e[(e.Object = 4)] = "Object"),
      (e[(e.Set = 5)] = "Set"),
      (e[(e.Map = 6)] = "Map"),
      (e[(e.Dynamic = 7)] = "Dynamic")
  })(c || (c = {}))
  const i = { [o]: c.Number, get: () => 0 },
    a = { [o]: c.String, get: () => "" },
    u = { [o]: c.Boolean, get: () => !1 }
  function f(e) {
    return o in e
  }
  function d(e) {
    return o in e
  }
  function p(e) {
    if (!f(e)) return !1
    const t = e[o]
    return (
      t === c.Number || t === c.String || t === c.Boolean || t === c.Dynamic
    )
  }
  function h(e, t) {
    if (((t[e.id] = e), f(e))) "element" in e && h(e.element, t)
    else for (let n = 0; n < e.fields.length; n++) h(e.fields[n], t)
  }
  function g(e) {
    const t = {}
    for (const n in e) h(e[n], (t[n] = {}))
    return t
  }
  function y(e) {
    const t = {},
      n = { id: -1 }
    return (
      e.forEach((e, r) => {
        ;(n.id = -1),
          (t[r] = (function e(t, n, r = !1) {
            let o,
              s = { id: ++n.id, lo: n.id, hi: n.id, deep: r }
            if (f(t))
              (o = { ...s, ...t }),
                "element" in o && (o.element = e(o.element, n, !0))
            else {
              const c = Object.keys(t),
                l = [],
                i = {},
                a = {}
              for (let o = 0; o < c.length; o++) {
                const s = c[o],
                  u = e(t[s], n, r)
                ;(i[s] = u), (a[s] = u.id), l.push(u)
              }
              o = { ...s, keys: c, fields: l, fieldsByKey: i, fieldIdsByKey: a }
            }
            return (o.hi = n.id), o
          })(e, n))
      }),
      Object.defineProperty(t, s, { enumerable: !1, writable: !1, value: g(t) })
    )
  }
  function m(e, t, n) {
    const r = [],
      o = () => {
        for (let t = 0; t < n; t++) r.push(e(s))
      },
      s = {
        allocate: o,
        retain: () => (r.length || o(), r.pop()),
        release: e => {
          r.push(t(e))
        },
      }
    return s
  }
  const b = () => {
      const e = []
      return {
        subscribe: t => (
          e.push(t),
          () =>
            (function (e, t) {
              const n = e.length,
                r = e.indexOf(t)
              if (-1 === r) return !1
              const o = e.pop()
              return r < n - 1 && (e[r] = o), !0
            })(e, t)
        ),
        dispatch: (t, n, r, o) => {
          for (let s = 0; s < e.length; s++) e[s](t, n, r, o)
        },
      }
    },
    v = {
      schemaIndex: new WeakMap(),
      schemaPools: new Map(),
      model: { [s]: {} },
      worlds: [],
      worldIds: 0,
      currentWorldId: -1,
    },
    _ = b()
  function S(e) {
    ;(v.model = e), _.dispatch(e)
  }
  let w = 0
  function I(e, t) {
    return m(
      () => {
        return (function e(t, n) {
          for (const r in n) {
            const o = n[r]
            let s
            ;(s = d(o) ? o.get() : e({}, o)), (t[r] = s)
          }
          return t
        })(
          ((t = e),
          Object.defineProperties(
            {},
            {
              __type__: {
                value: v.schemaIndex.get(t),
                writable: !1,
                enumerable: !0,
              },
            },
          )),
          e,
        )
        var t
      },
      t =>
        (function e(t, n) {
          for (const r in n) {
            const o = n[r]
            d(o) ? (t[r] = o.get(t[r])) : e(t[r], o)
          }
          return t
        })(t, e),
      t,
    )
  }
  const k = new Map()
  function O(e, t, n = 1e3) {
    let r = v.schemaIndex.get(e)
    if (void 0 !== r) return r
    if (((r = t), void 0 === r)) {
      for (; k.has(w); ) w++
      r = w
    } else if (k.has(r)) throw new Error("Failed to register component type: a component with same id is already registered")
    return (
      v.schemaPools.set(r, I(e, n)),
      k.set(r, e),
      v.schemaIndex.set(e, r),
      S(y(k)),
      r
    )
  }
  function x(e, t = { throw: !1, global: !1 }) {
    const { global: n } = t,
      r = []
    let o,
      s,
      c,
      l,
      i,
      a = -1
    return function (...t) {
      l = v.currentWorldId
      const u = v.worlds[l],
        f = u.latestTick
      i = n ? 0 : u.latestSystemId
      let d = r[l]
      void 0 === r[l] && (d = r[l] = [])
      let p = d[i]
      if (
        (void 0 === p && (p = d[i] = { cells: [], cellCount: -1 }),
        !0 === n || (s !== l && void 0 !== s))
      )
        a = 0
      else if (void 0 === c || (o === f && c === i)) a++
      else {
        let e = d[c]
        if (-1 !== e.cellCount && e.cellCount !== a)
          throw new Error(
            `Failed to execute effect: encountered too ${
              e.cellCount > a ? "few" : "many"
            } effects this step`,
          )
        ;(e.cellCount = a), (a = 0)
      }
      let h = p.cells[a]
      if (
        (h ||
          (h = p.cells[a] =
            {
              executor: e(u),
              lockGlobal: !1,
              lockAsync: !1,
              lockGlobalTick: null,
              state: null,
            }),
        n &&
          (h.lockGlobalTick !== u.latestTick
            ? ((h.lockGlobal = !1), (h.lockGlobalTick = u.latestTick))
            : (h.lockGlobal = !0)),
        h.lockGlobal || h.lockAsync)
      )
        return h.state
      const g = h.executor(...t)
      var y
      return (
        "object" == typeof (y = g) && null !== y && "then" in y
          ? ((h.lockAsync = !0),
            g
              .then(e => (h.state = e))
              .catch(e =>
                console.error("Uncaught error in effect: " + e.message, e),
              )
              .then(() => (h.lockAsync = !1)))
          : (h.state = g),
        (o = f),
        (s = l),
        (c = i),
        h.state
      )
    }
  }
  const j = x(() => {
      let e = !0
      const t = { value: null }
      return function (n) {
        return e && ((t.value = n), (e = !1)), t
      }
    }),
    A = x(() => {
      let e,
        t = 0
      return function (n, r = !1) {
        return (
          r && ((t = 0), clearTimeout(e)),
          0 === t &&
            ((t = 1),
            (e = setTimeout(() => {
              t = 2
            }, n))),
          2 === t
        )
      }
    }),
    C = x(
      () =>
        function (e) {
          const t = j(!1),
            n = A(e, t.value)
          return (t.value = n), n
        },
    ),
    D = m(
      () => [-1, [], []],
      e => ((e[0] = -1), l(e[1]), l(e[2]), e),
      1e3,
    ),
    E = x(e => {
      const {
        storage: {
          entityRelocating: t,
          entityRelocated: n,
          archetypes: [r],
        },
      } = e
      let o = [],
        s = [],
        c = [],
        i = [],
        a = null
      return (
        t.subscribe(function (e, t, n, c) {
          if (null === a) return
          const l = a.matchesArchetype(t)
          if (l && n === r) {
            const t = o.findIndex(([t]) => t === e)
            ;-1 !== t && o.splice(t, 1)
          }
          if (l && !a.matchesArchetype(n)) {
            const t = D.retain()
            ;(t[0] = e), a.get(e, t[1]), a.match(c, t[2]), s.push(t)
          }
        }),
        n.subscribe(function (e, t, n, r) {
          if (null !== a && !a.matchesArchetype(t) && a.matchesArchetype(n)) {
            const t = D.retain()
            ;(t[0] = e), a.get(e, t[1]), a.match(r, t[2]), o.push(t)
          }
        }),
        function (e, t, n) {
          let r
          for (
            a === e ||
              (null == a ? void 0 : a.equals(e)) ||
              (e => {
                ;(a = e), l(o), l(s), l(c), l(i)
                for (const [t] of e)
                  for (let n = 0; n < t.length; n++) {
                    const r = t[n],
                      s = D.retain()
                    ;(s[0] = r), e.get(r, s[1]), e.get(r, s[2]), o.push(s)
                  }
              })(e),
              l(c),
              l(i);
            void 0 !== (r = o.pop());

          )
            c.push(r)
          for (; void 0 !== (r = s.pop()); ) i.push(r)
          if (void 0 !== t)
            for (let e = 0; e < c.length; e++) {
              const n = c[e]
              t(n[0], n[1], n[2]), D.release(n)
            }
          if (void 0 !== n)
            for (let e = 0; e < i.length; e++) {
              const t = i[e]
              n(t[0], t[1], t[2]), D.release(t)
            }
        }
      )
    })
  const M = x(() => {
      let e,
        t = { response: null, error: null, done: !1 },
        n = !1,
        r = new window.AbortController()
      return function (o, s, c = void 0 !== e && o !== e) {
        return (
          (null === o || c) && (r.abort(), (r = new AbortController())),
          null === o
            ? t
            : (c && (t = { response: t.response, error: null, done: !1 }),
              t.done ||
                n ||
                ((n = !0),
                (e = o),
                fetch(o, { ...s, signal: r.signal })
                  .then(e => {
                    t = { response: e, error: null, done: !0 }
                  })
                  .catch(e => {
                    t = { response: t.response, error: e, done: !0 }
                  })
                  .then(() => {
                    n = !1
                  })),
              t)
        )
      }
    }),
    T = x(() => {
      let e
      return function (...t) {
        const n = j(null),
          r = M(...t)
        return (
          r.response &&
            r.response !== n.value &&
            (r.response.json().then(t => {
              e = t
            }),
            (n.value = r.response)),
          { ...r, response: e || null }
        )
      }
    }),
    P = Symbol("javelin_proxy_touched"),
    B = Symbol("javelin_proxy_self"),
    F = Symbol("javelin_proxy_node"),
    W = Symbol("javelin_proxy_changes"),
    N = Symbol("javelin_proxy_deleted"),
    R = new WeakMap(),
    G = {
      get: (e, t) => (t === B ? e : ((e[P] = !0), e[t])),
      set(e, t, n) {
        const r = e[W]
        return (e[t] = n), (e[P] = !0), (r.changes[t] = n), (r.dirty = !0), !0
      },
    },
    Q = {
      get(e, t) {
        if (t === B) return e
        const n = e[t]
        return (
          (e[P] = !0), "object" == typeof n && null !== n ? ee(n, e[F], t) : n
        )
      },
      set: G.set,
    },
    $ = G,
    q = { get: Q.get, set: $.set },
    U = {
      ...G,
      deleteProperty(e, t) {
        const n = e[W]
        return delete e[t], (e[P] = !0), (n.changes[t] = N), (n.dirty = !0), !0
      },
    },
    K = { ...Q, deleteProperty: U.deleteProperty },
    z = {
      get(e, t) {
        if (t === B) return e
        const n = e[t]
        return (e[P] = !0), "function" == typeof n ? new Proxy(n, J) : n
      },
    },
    J = {
      apply(e, t, n) {
        const { [B]: r, [W]: o } = t
        switch (((t[P] = !0), e)) {
          case Set.prototype.add:
            o.changes.add.push(n[0]), (o.dirty = !0)
            break
          case Set.prototype.delete:
            o.changes.delete.push(n[0]), (o.dirty = !0)
            break
          case Set.prototype.clear:
            r.forEach(e => o.changes.delete.push(e)), (o.dirty = !0)
        }
        return e.apply(r, n)
      },
    },
    H = {
      get(e, t, n) {
        if (t === B) return e
        const r = Reflect.get(e, t, n)
        return (e[P] = !0), "function" == typeof r ? new Proxy(r, L) : r
      },
    },
    L = {
      apply(e, t, n) {
        const { [B]: r } = t,
          { [W]: o } = r
        switch (((r[P] = !0), e)) {
          case Map.prototype.get: {
            const t = e.apply(r, n)
            if ("object" == typeof t && null !== t) return ee(t, r[F], n[0])
          }
          case Map.prototype.set:
            o.changes.set(n[0], n[1]), (o.dirty = !0)
            break
          case Map.prototype.delete:
            o.changes.set(n[0], N), (o.dirty = !0)
            break
          case Map.prototype.clear:
            return (
              r.forEach((e, t) => o.changes.set(t, N)),
              (o.dirty = !0),
              r.clear()
            )
        }
        return e.apply(r, n)
      },
    }
  function V(e) {
    const t = (function (e) {
      return f(e) ? !("element" in e) || p(e.element) : e.fields.every(p)
    })(e)
    if (f(e))
      switch (e[o]) {
        case c.Array:
          return t ? $ : q
        case c.Object:
          return t ? U : K
        case c.Set:
          return z
        case c.Map:
          return H
        default:
          throw new Error(
            "Failed to observe object: cannot observe a primitive type",
          )
      }
    return t ? G : Q
  }
  function X(e) {
    if (f(e))
      switch (e[o]) {
        case c.Array:
        case c.Object:
          return { dirty: !1, changes: {} }
        case c.Set:
          return { dirty: !1, changes: { add: [], delete: [] } }
        case c.Map:
          return { dirty: !1, changes: new Map() }
      }
    return { dirty: !1, changes: {} }
  }
  const Y = { configurable: !1, enumerable: !0, writable: !1 }
  function Z(e, t) {
    Object.defineProperties(e, {
      [B]: { ...Y, value: e },
      [F]: { ...Y, value: t },
      [W]: { ...Y, value: X(t) },
    })
    const n = new Proxy(e, V(t))
    return R.set(e, n), n
  }
  function ee(e, n, r) {
    var s
    let c
    return (
      !(function (e) {
        return !(o in e)
      })(n)
        ? (t("element" in n), (c = n.element))
        : (c = n.fieldsByKey[r]),
      null !== (s = R.get(e)) && void 0 !== s ? s : Z(e, c)
    )
  }
  const te = { ref: null, key: null }
  function ne(e, n, r, s) {
    let l = 0,
      i = null,
      a = n,
      u = e[n.__type__]
    e: for (; u.id !== r; )
      if (f(u)) {
        switch ((t("element" in u), (i = s[l++]), u[o])) {
          case c.Array:
          case c.Object:
            a = a[i]
            break
          case c.Map:
            a = a.get(i)
            break
          default:
            throw new Error("Failed to apply change: invalid target field")
        }
        u = u.element
      } else
        for (let e = 0; e < u.fields.length; e++) {
          const t = u.fields[e]
          if (t.lo <= r && t.hi >= r) {
            ;(i = u.keys[e]), (u = t), u.id !== r && (a = a[i])
            continue e
          }
        }
    return (te.ref = a), (te.key = i), te
  }
  const re =
      "a query must be executed within a system or bound to a world using Query.bind()",
    oe = (e, t, n) =>
      (function (e, t) {
        let n = 0,
          r = 0
        if (e.length < t.length) return !1
        for (; n < e.length && r < t.length; )
          if (e[n] < t[r]) n++
          else {
            if (e[n] !== t[r]) return !1
            n++, r++
          }
        return r === t.length
      })(n.signature, e) && n.signature.every(e => !t.not.has(e))
  function se(e) {
    const t = "snapshot" in e ? e.snapshot : null,
      n = t ? Object.keys(t.indices).map(Number) : [],
      r = t
        ? (function (e) {
            const t = []
            for (const n in e) {
              const r = parseInt(n, 10)
              isNaN(r) || (t[r] = e[n])
            }
            return t
          })(t.indices)
        : [],
      o = ("signature" in e ? e.signature : e.snapshot.signature)
        .slice()
        .sort((e, t) => e - t),
      s = t ? t.table.map(e => e.slice()) : o.map(() => []),
      c = o.reduce((e, t, n) => ((e[t] = n), e), [])
    return {
      entities: n,
      indices: r,
      signature: o,
      signatureInverse: c,
      table: s,
    }
  }
  function ce(e) {
    const {
      signature: t,
      signatureInverse: n,
      entities: r,
      indices: o,
      table: s,
    } = se(e)
    return {
      entities: r,
      indices: o,
      insert: function (e, t) {
        for (let e = 0; e < t.length; e++) {
          const r = t[e],
            o = n[r.__type__]
          s[o].push(r)
        }
        o[e] = r.push(e) - 1
      },
      remove: function (e) {
        const t = r.length,
          n = o[e],
          c = r.pop()
        if ((delete o[e], n === t - 1)) for (const e of s) e.pop()
        else {
          for (const e of s) e[n] = e.pop()
          ;(r[n] = c), (o[c] = n)
        }
      },
      signature: t,
      signatureInverse: n,
      table: s,
    }
  }
  const le = "Failed to locate component: schema not registered"
  function ie(e = {}) {
    const n = e.snapshot
        ? e.snapshot.archetypes.map(e => ce({ snapshot: e }))
        : [ce({ signature: [] })],
      r = [],
      o = b(),
      s = b(),
      c = b()
    function i(e) {
      let t = (function (e) {
        const t = e.length
        e: for (let r = 0; r < n.length; r++) {
          const o = n[r],
            { signature: s, signatureInverse: c } = o
          if (s.length === t) {
            for (let n = 0; n < t; n++)
              if (void 0 === c[e[n].__type__]) continue e
            return o
          }
        }
        return null
      })(e)
      return (
        null === t &&
          ((t = ce({ signature: e.map(e => e.__type__) })),
          n.push(t),
          c.dispatch(t)),
        t
      )
    }
    function a(e) {
      const n = r[e]
      return (
        t(void 0 !== n, "Failed to locate entity: entity has not been created"),
        t(null !== n, "Failed to locate entity: entity has been destroyed"),
        n
      )
    }
    function u(e, t, n, c) {
      const l = i(n)
      o.dispatch(t, e, l, c),
        e.remove(t),
        l.insert(t, n),
        (r[t] = l),
        s.dispatch(t, e, l, c)
    }
    function f(e, t) {
      const c = r[e]
      if (null == c) {
        const c = i(t)
        o.dispatch(e, n[0], c, t),
          c.insert(e, t),
          (r[e] = c),
          s.dispatch(e, n[0], c, t)
      } else {
        const n = c.indices[e],
          r = t.slice()
        for (let e = 0; e < c.signature.length; e++) {
          const o = c.signature[e]
          t.find(e => e.__type__ === o) || r.push(c.table[e][n])
        }
        u(c, e, r, t)
      }
    }
    function d(e, t) {
      const n = a(e),
        r = [],
        o = [],
        s = n.indices[e]
      for (let e = 0; e < n.signature.length; e++) {
        const c = n.signature[e],
          l = n.table[e][s]
        ;(t.includes(c) ? r : o).push(l)
      }
      u(n, e, o, r)
    }
    const p = []
    function h(e, t) {
      const n = a(e),
        r = n.signatureInverse[t]
      if (void 0 === r) return null
      const o = n.indices[e]
      return n.table[r][o]
    }
    return {
      archetypeCreated: c,
      archetypes: n,
      attachComponents: f,
      attachOrUpdateComponents: function (e, t) {
        const n = a(e),
          r = n.indices[e]
        l(p)
        for (let e = 0; e < t.length; e++) {
          const o = t[e],
            s = n.signatureInverse[o.__type__]
          void 0 === s ? p.push(o) : Object.assign(n.table[s][r], o)
        }
        p.length > 0 && f(e, p)
      },
      reset: function () {
        l(n), l(r)
      },
      clearComponents: function (e) {
        d(e, a(e).signature), (r[e] = null)
      },
      detachBySchemaId: d,
      entityRelocated: s,
      entityRelocating: o,
      getComponentBySchemaId: h,
      getComponentBySchema: function (e, n) {
        const r = v.schemaIndex.get(n)
        return t(void 0 !== r, le), h(e, r)
      },
      getAllComponents: function (e) {
        const t = a(e),
          n = t.indices[e],
          r = []
        for (let e = 0; e < t.table.length; e++) r.push(t.table[e][n])
        return r
      },
      getSnapshot: function () {
        return {
          archetypes: n.map(e => {
            return {
              signature: e.signature.slice(),
              table: e.table.map(e => e.map(e => ({ ...e }))),
              indices:
                ((t = e.indices), t.reduce((e, t, n) => ((e[n] = t), e), {})),
            }
            var t
          }),
        }
      },
      hasComponentOfSchema: function (e, n) {
        const r = a(e),
          o = v.schemaIndex.get(n)
        return t(void 0 !== o, le), r.signature.includes(o)
      },
    }
  }
  const ae = Symbol("javelin_system_id")
  var ue
  ;((ue = e.DeferredOpType || (e.DeferredOpType = {}))[(ue.Spawn = 0)] =
    "Spawn"),
    (ue[(ue.Attach = 1)] = "Attach"),
    (ue[(ue.Detach = 2)] = "Detach"),
    (ue[(ue.Mutate = 3)] = "Mutate"),
    (ue[(ue.Destroy = 4)] = "Destroy"),
    (e.$changes = W),
    (e.$delete = N),
    (e.$self = B),
    (e.$touched = P),
    (e.$type = F),
    (e.UNSAFE_internals = v),
    (e.UNSAFE_modelChanged = _),
    (e.UNSAFE_setModel = S),
    (e.apply = function (e, t, n, r, o) {
      const { key: s, ref: c } = ne(e, t, n, r)
      c[s] = o
    }),
    (e.arrayOf = function (e) {
      return { [o]: c.Array, get: (e = []) => l(e), element: e }
    }),
    (e.boolean = u),
    (e.clear = function (e) {
      var t
      const n = null !== (t = e[B]) && void 0 !== t ? t : e
      return (function e(t, n) {
        if (!0 !== t[P]) return
        const r = t[W]
        if (f(n)) {
          if ("element" in n) {
            const s = n.element
            switch (n[o]) {
              case c.Array:
                for (const e in r.changes) delete r.changes[e]
                for (let n = 0; n < t.length; n++) e(t[n], s)
                break
              case c.Object:
                for (const e in r.changes) delete r.changes[e]
                for (const n in t) e(t[n], s)
                break
              case c.Set:
                l(r.changes.add), l(r.changes.delete)
                break
              case c.Map:
                r.changes.clear(), t.forEach(t => e(t, s))
            }
          }
        } else {
          for (const e in r.changes) delete r.changes[e]
          for (let r = 0; r < n.fields.length; r++) e(t[n.keys[r]], n.fields[r])
        }
        ;(r.dirty = !1), (t[P] = !1)
      })(n, v.model[n.__type__])
    }),
    (e.component = function (e, t) {
      const n = O(e),
        r = v.schemaPools.get(n).retain()
      return void 0 !== t && Object.assign(r, t), r
    }),
    (e.createComponentPool = I),
    (e.createEffect = x),
    (e.createQuery = (...e) =>
      (function e(r) {
        var o, s
        const c = r.select.length,
          i = null !== (o = r.filters) && void 0 !== o ? o : { not: new Set() },
          a = r.select.map(e => O(e)).sort((e, t) => e - t),
          u = (null !== (s = r.include) && void 0 !== s ? s : r.select).map(e =>
            O(e),
          ),
          f = []
        let d = r.context
        const p = (e, t) => {
            if (oe(a, i, e)) {
              const n = u.map(t => e.table[e.signature.indexOf(t)])
              t.push([e.entities, n, e.indices])
            }
          },
          h = e => {
            const t = v.worlds[e],
              n = []
            return (
              (f[e] = n),
              t.storage.archetypes.forEach(e => p(e, n)),
              t.storage.archetypeCreated.subscribe(e => p(e, n)),
              n
            )
          },
          g = m(
            () => [],
            e => (l(e), e),
            1e3,
          ),
          y = e => {
            const r = null != d ? d : v.currentWorldId
            t(null !== r && -1 !== r, re, n.Query)
            const o = f[r] || h(r),
              s = g.retain()
            for (let t = 0; t < o.length; t++) {
              const [n, r] = o[t]
              for (let t = 0; t < n.length; t++) {
                for (let e = 0; e < c; e++) s[e] = r[e][t]
                e(n[t], s)
              }
            }
            g.release(s)
          }
        return (
          (y.signature = a),
          (y.filters = i),
          (y.not = (...t) =>
            e({
              ...r,
              filters: {
                not: new Set(
                  t
                    .map(e => v.schemaIndex.get(e))
                    .filter(e => "number" == typeof e),
                ),
              },
            })),
          (y.select = (...t) => e({ ...r, include: t })),
          (y.get = (e, t = []) => {
            const n = null != d ? d : v.currentWorldId,
              r = f[n]
            for (let n = 0; n < r.length; n++) {
              const [, o, s] = r[n],
                c = s[e]
              if (void 0 !== c) {
                for (let e = 0; e < o.length; e++) t[e] = o[e][c]
                return t
              }
            }
            throw new Error(
              "Failed to get components of query: entity does not match query",
            )
          }),
          (y.bind = t => e({ ...r, context: t.id })),
          (y.test = e => {
            const t = null != d ? d : v.currentWorldId,
              n = f[t]
            for (let t = 0; t < n.length; t++) {
              if (void 0 !== n[t][2][e]) return !0
            }
            return !1
          }),
          (y.matchesArchetype = e => oe(a, i, e)),
          (y[Symbol.iterator] = () => {
            const e = null != d ? d : v.currentWorldId
            t(null !== e && -1 !== e, re, n.Query)
            return (f[e] || h(e))[Symbol.iterator]()
          }),
          (y.equals = e => {
            if (e.signature.length !== a.length) return !1
            for (let t = 0; t < e.signature.length; t++)
              if (e.signature[t] !== a[t]) return !1
            if (e.filters.not.size !== i.not.size) return !1
            let t = !0
            return e.filters.not.forEach(e => (t = t && i.not.has(e))), t
          }),
          (y.match = (e, t = []) => {
            for (let e = 0; e < u.length; e++) t[e] = null
            for (let n = 0; n < e.length; n++) {
              const r = e[n],
                o = u.indexOf(r.__type__)
              ;-1 !== o && (t[o] = r)
            }
            return t
          }),
          y
        )
      })({ select: e })),
    (e.createRef = (e, t = {}) =>
      x(t => {
        const n = e(t)
        return () => j(n)
      }, t)),
    (e.createTopic = () => {
      const e = [],
        t = []
      return {
        *[Symbol.iterator]() {
          for (let e = 0; e < t.length; e++) yield t[e]
        },
        push: t => e.push(t),
        pushImmediate: e => t.push(e),
        flush: () => {
          l(t)
          for (let n = e.length - 1; n >= 0; n--) t[n] = e.pop()
        },
        clear: () => {
          l(e), l(t)
        },
      }
    }),
    (e.createWorld = function (n = {}) {
      var r, o
      const { topics: s = [] } = n,
        c = [],
        i = [],
        a = m(() => [], l, 1e3),
        u = new Set(),
        f = ie({
          snapshot:
            null === (r = n.snapshot) || void 0 === r ? void 0 : r.storage,
        })
      let d = 0,
        p = 0
      function h(...e) {
        const t = a.retain()
        for (let n = 0; n < e.length; n++) t[n] = e[n]
        return t
      }
      function g(e) {
        const t = v.schemaPools.get(e.__type__)
        t && t.release(e)
      }
      function y(e) {
        c.push(e), (e[ae] = p++)
      }
      function b(e, t) {
        f.attachComponents(e, t)
      }
      function _(e, n) {
        const r = []
        for (let o = 0; o < n.length; o++) {
          const s = n[o],
            c = f.getComponentBySchemaId(e, s)
          t(
            null !== c,
            "Failed to detach component: entity does not have component of type " +
              s,
          ),
            r.push(c)
        }
        f.detachBySchemaId(e, n), r.forEach(g)
      }
      function S(e) {
        f.clearComponents(e)
      }
      function w(t) {
        switch (t[0]) {
          case e.DeferredOpType.Attach:
            !(function (e) {
              const [, t, n] = e
              b(t, n)
            })(t)
            break
          case e.DeferredOpType.Detach:
            !(function (e) {
              const [, t, n] = e
              _(t, n)
            })(t)
            break
          case e.DeferredOpType.Destroy:
            !(function (e) {
              const [, t] = e
              S(t)
            })(t)
        }
        a.release(t)
      }
      null === (o = n.systems) || void 0 === o || o.forEach(y)
      const I = v.worldIds++,
        k = {
          id: I,
          storage: f,
          latestTick: -1,
          latestTickData: null,
          latestSystemId: -1,
          attach: function (t, ...n) {
            i.push(h(e.DeferredOpType.Attach, t, n))
          },
          attachImmediate: b,
          addSystem: y,
          addTopic: function (e) {
            s.push(e)
          },
          create: function (...t) {
            const n = d++
            return t.length > 0 && i.push(h(e.DeferredOpType.Attach, n, t)), n
          },
          destroy: function (t) {
            u.has(t) || (i.push(h(e.DeferredOpType.Destroy, t)), u.add(t))
          },
          destroyImmediate: S,
          get: function (e, t) {
            O(t)
            const n = f.getComponentBySchema(e, t)
            if (null === n)
              throw new Error(
                "Failed to get component: entity does not have component",
              )
            return n
          },
          getSnapshot: function () {
            return { storage: f.getSnapshot() }
          },
          has: function (e, t) {
            return O(t), f.hasComponentOfSchema(e, t)
          },
          detach: function (t, ...n) {
            if (0 === n.length) return
            const r = n.map(e => {
              var t
              return "number" == typeof e
                ? e
                : null !== (t = v.schemaIndex.get(e)) && void 0 !== t
                ? t
                : e.__type__
            })
            i.push(h(e.DeferredOpType.Detach, t, r))
          },
          detachImmediate: _,
          removeSystem: function (e) {
            const t = c.indexOf(e)
            t > -1 && c.splice(t, 1)
          },
          removeTopic: function (e) {
            const t = s.indexOf(e)
            t > -1 && s.splice(t, 1)
          },
          reset: function () {
            for (u.clear(); i.length > 0; ) a.release(i.pop())
            l(i),
              l(c),
              s.forEach(e => e.clear()),
              l(s),
              (d = 0),
              (k.latestTick = -1),
              (k.latestTickData = null),
              (k.latestSystemId = -1)
            for (let e = 0; e < f.archetypes.length; e++) {
              const t = f.archetypes[e]
              for (let e = 0; e < t.signature.length; e++) {
                const n = t.table[e],
                  r = v.schemaPools.get(t.signature[e])
                for (let e = 0; e < n.length; e++) {
                  const t = n[e]
                  null == r || r.release(t)
                }
              }
            }
            f.reset()
          },
          step: function (e) {
            let t = v.currentWorldId
            ;(v.currentWorldId = I), (k.latestTickData = e)
            for (let e = 0; e < i.length; e++) w(i[e])
            l(i)
            for (let e = 0; e < s.length; e++) s[e].flush()
            for (let e = 0; e < c.length; e++) {
              const t = c[e]
              ;(k.latestSystemId = t[ae]), t(k)
            }
            u.clear(), k.latestTick++, (v.currentWorldId = t)
          },
          tryGet: function (e, t) {
            return O(t), f.getComponentBySchema(e, t)
          },
        }
      return v.worlds.push(k), k
    }),
    (e.getFieldRef = ne),
    (e.isComponentOf = function (e, t) {
      return e.__type__ === v.schemaIndex.get(t)
    }),
    (e.mapOf = function (e, t) {
      return {
        [o]: c.Map,
        get: (e = new Map()) => (e.clear(), e),
        key: e,
        element: t,
      }
    }),
    (e.number = i),
    (e.objectOf = function (e, t = a) {
      return {
        [o]: c.Object,
        get: (e = {}) => {
          for (const t in e) delete e[t]
          return e
        },
        key: t,
        element: e,
      }
    }),
    (e.observe = function (e) {
      var t
      return (
        (e[P] = !0),
        null !== (t = R.get(e)) && void 0 !== t ? t : Z(e, v.model[e.__type__])
      )
    }),
    (e.registerSchema = O),
    (e.setOf = function (e) {
      return { [o]: c.Set, get: (e = new Set()) => (e.clear(), e), element: e }
    }),
    (e.string = a),
    (e.useInterval = C),
    (e.useJson = T),
    (e.useMonitor = E),
    (e.useRef = j),
    (e.useRequest = M),
    (e.useTimer = A),
    (e.useWorld = function () {
      return v.worlds[v.currentWorldId]
    }),
    Object.defineProperty(e, "__esModule", { value: !0 })
})
