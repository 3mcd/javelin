(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Javelin = {}));
}(this, (function (exports) { 'use strict';

    /**
     * Create an Archetype.
     *
     * @param layout Array of component types that make up the archetype
     */
    function createArchetype(layout) {
        const len = layout.length;
        const table = [];
        const entities = [];
        const indices = [];
        const layoutInverse = layout.reduce((a, x, i) => {
            a[x] = i;
            return a;
        }, []);
        // Initialize the table with an empty collection of components for each
        // component type.
        for (let i = 0; i < len; i++) {
            table[i] = [];
        }
        function insert(entity, components) {
            for (let i = 0; i < components.length; i++) {
                const component = components[i];
                const componentTypeIndex = layoutInverse[component._tid];
                table[componentTypeIndex].push(component);
            }
            indices[entity] = entities.push(entity) - 1;
        }
        function remove(entity) {
            const length = entities.length;
            const index = indices[entity];
            const head = entities.pop();
            indices[entity] = -1;
            if (index === length - 1) {
                for (const column of table)
                    column.pop();
                return;
            }
            // Move leading entity's components to removed index position
            for (const column of table) {
                column[index] = column.pop();
            }
            // Move leading entity to removed index position
            entities[index] = head;
            // Update previously leading entity's index
            indices[head] = index;
        }
        return {
            layout,
            layoutInverse,
            table,
            indices,
            entities,
            insert,
            remove,
        };
    }

    (function (ComponentState) {
        ComponentState[ComponentState["Orphaned"] = 0] = "Orphaned";
        ComponentState[ComponentState["Attaching"] = 1] = "Attaching";
        ComponentState[ComponentState["Attached"] = 2] = "Attached";
        ComponentState[ComponentState["Detaching"] = 3] = "Detaching";
        ComponentState[ComponentState["Detached"] = 4] = "Detached";
    })(exports.ComponentState || (exports.ComponentState = {}));

    const globals = {
        __WORLDS__: [],
        __CURRENT_WORLD__: -1,
        __CURRENT_SYSTEM__: -1,
    };

    function createEffect(factory, options = { throw: false, global: false }) {
        const systemCellCountLookup = [];
        const effectLookup = [];
        const stateLookup = [];
        let previousTick;
        let previousWorld;
        let previousSystem;
        let currentWorld;
        let currentSystem;
        let cellCount = -1;
        const onState = (nextState, w, s, c) => (stateLookup[w][s][c] = nextState);
        return (...args) => {
            currentWorld = globals.__CURRENT_WORLD__;
            currentSystem = options.global ? 0 : globals.__CURRENT_SYSTEM__;
            const world = globals.__WORLDS__[currentWorld];
            const currentTick = world.state.currentTick;
            if (previousWorld !== currentWorld && previousWorld !== undefined) ;
            else if (previousTick !== currentTick ||
                (previousSystem !== currentSystem && previousSystem !== undefined)) {
                let systemCellCount = systemCellCountLookup[currentWorld];
                if (systemCellCountLookup[currentWorld] === undefined) {
                    systemCellCount = systemCellCountLookup[currentWorld] = [];
                }
                const previousCellCount = systemCellCount[previousSystem];
                if (previousCellCount !== undefined && previousCellCount !== cellCount) {
                    throw new Error("woops");
                }
                systemCellCount[previousSystem] = cellCount;
                cellCount = 0;
            }
            else {
                cellCount++;
            }
            if (stateLookup[currentWorld] === undefined) {
                stateLookup[currentWorld] = [];
            }
            let cellLookup = stateLookup[currentWorld][currentSystem];
            if (cellLookup === undefined) {
                cellLookup = stateLookup[currentWorld][currentSystem] = [];
            }
            if (effectLookup[currentWorld] === undefined) {
                effectLookup[currentWorld] = [];
            }
            let executorLookup = effectLookup[currentWorld][currentSystem];
            if (executorLookup === undefined) {
                executorLookup = effectLookup[currentWorld][currentSystem] = [];
            }
            let executor = executorLookup[cellCount];
            let state = cellLookup[cellCount];
            if (executor === undefined) {
                executor = factory();
                executorLookup[cellCount] = executor;
            }
            else if (executor.running === true) {
                return state;
            }
            const result = executor(world, ...args);
            if (typeof result === "object" && result !== null && "then" in result) {
                let w = currentWorld;
                let s = currentSystem;
                let c = cellCount;
                executor.running = true;
                result
                    .then(result => onState(result, w, s, c))
                    .catch(error => console.error(`Uncaught error in effect: ${error.message}`, error))
                    .then(() => (executor.running = false));
            }
            else {
                state = onState(result, currentWorld, currentSystem, cellCount);
            }
            previousTick = currentTick;
            previousWorld = currentWorld;
            previousSystem = currentSystem;
            return state;
        };
    }

    function createComponentFilter(getPredicate) {
        return (componentType) => ({
            componentType,
            componentPredicate: getPredicate(),
        });
    }

    const attached = createComponentFilter(() => ({ _cst: _cst }) => _cst === exports.ComponentState.Attaching);

    const changed = createComponentFilter(() => (c, { isComponentChanged }) => isComponentChanged(c));

    const detached = createComponentFilter(() => ({ _cst: _cst }) => _cst === exports.ComponentState.Detached);

    function createStackPool(type, reset, size) {
        const heap = [];
        const allocate = () => {
            for (let i = 0; i < size; i++) {
                heap.push(type(pool));
            }
        };
        const retain = () => {
            if (!heap.length) {
                allocate();
            }
            return heap.pop();
        };
        const release = (obj) => {
            heap.push(reset(obj));
        };
        const pool = {
            allocate,
            retain,
            release,
        };
        return pool;
    }

    const $isDataType = Symbol("is_data_type");

    function createDataType(config) {
        return { ...config, [$isDataType]: true };
    }
    function isDataType(obj) {
        return typeof obj === "object" && obj !== null && obj[$isDataType];
    }
    function initializeComponentFromSchema(component, schema) {
        for (const prop in schema) {
            const value = schema[prop];
            if (isDataType(value)) {
                // DataType
                component[prop] = value.create(undefined);
            }
            else if ("type" in value && isDataType(value.type)) {
                // DataType with defaultValue
                const { type, defaultValue } = value;
                component[prop] = type.create(defaultValue);
            }
            else {
                // Schema
                initializeComponentFromSchema(component, value);
            }
        }
        return component;
    }
    function resetComponentFromSchema(component, schema) {
        component._cst = exports.ComponentState.Orphaned;
        for (const prop in schema) {
            const value = schema[prop];
            if (isDataType(value)) {
                // DataType
                value.reset(component, prop, undefined);
            }
            else if ("type" in value && isDataType(value.type)) {
                // DataType with defaultValue
                const { type, defaultValue } = value;
                type.reset(component, prop, defaultValue);
            }
            else {
                // Schema
                resetComponentFromSchema(component, value);
            }
        }
        return component;
    }

    function createComponentType(componentType) {
        return componentType;
    }
    function createComponentBase(componentType) {
        return Object.defineProperties({}, {
            _tid: { value: componentType.type, writable: false, enumerable: true },
            _cst: {
                value: exports.ComponentState.Orphaned,
                writable: true,
                enumerable: false,
            },
        });
    }
    function createComponentPool(componentType, poolSize) {
        const componentPool = createStackPool(() => initializeComponentFromSchema(createComponentBase(componentType), componentType.schema), c => resetComponentFromSchema(c, componentType.schema), poolSize);
        return componentPool;
    }
    function isComponentOf(component, componentTypeId) {
        return component._tid === componentTypeId.type;
    }
    function flagComponent(component, state) {
        component._cst = state;
    }
    function flagComponents(components, state) {
        for (let i = 0; i < components.length; i++) {
            flagComponent(components[i], state);
        }
    }

    class QueryIterable {
        constructor(selector, onDone) {
            this.queryLength = -1;
            this.queryLayout = [];
            this.componentFilterPredicates = [];
            this.queryResult = [-1];
            this.readIndices = [];
            this.onDone = null;
            this.onDoneBound = () => this.onDone(this);
            this.entityIndex = -1;
            this.archetypeIndex = -1;
            this.currentArchetype = null;
            this.next = () => {
                if (this.currentArchetype === null) {
                    this.visitNextArchetype();
                }
                else {
                    this.visitNextEntity();
                }
                return this.iteratorResult;
            };
            this.componentFilterPredicates = selector.map(s => "componentPredicate" in s ? s.componentPredicate : null);
            this.queryLayout = selector.map(s => "componentType" in s ? s.componentType.type : s.type);
            this.queryLength = selector.length;
            this.iterable = {
                next: this.next,
            };
            this.iteratorResult = {
                value: this.queryResult,
                done: false,
            };
            this.onDone = onDone;
        }
        reset() {
            this.entityIndex = -1;
            this.archetypeIndex = -1;
            this.currentArchetype = null;
            this.iteratorResult.done = false;
        }
        visitNextArchetype() {
            const { queryLayout, queryLength, readIndices } = this;
            outer: while ((this.currentArchetype = globals.__WORLDS__[globals.__CURRENT_WORLD__].storage.archetypes[++this.archetypeIndex])) {
                const { layoutInverse } = this.currentArchetype;
                for (let i = 0; i < queryLength; i++) {
                    const index = layoutInverse[queryLayout[i]];
                    if (index === undefined) {
                        continue outer;
                    }
                    readIndices[i] = index;
                }
                this.entityIndex = -1;
                this.visitNextEntity();
                return;
            }
            this.iteratorResult.done = true;
            setTimeout(this.onDoneBound);
        }
        visitNextEntity() {
            var _a, _b;
            const { currentArchetype, readIndices, componentFilterPredicates } = this;
            const { table, entities } = currentArchetype;
            const length = entities.length;
            outer: while (++this.entityIndex < length) {
                this.queryResult[0] = entities[this.entityIndex];
                for (let i = 0; i < this.queryLength; i++) {
                    const component = table[readIndices[i]][this.entityIndex];
                    if ((_b = (_a = componentFilterPredicates[i]) === null || _a === void 0 ? void 0 : _a.call(componentFilterPredicates, component, globals.__WORLDS__[globals.__CURRENT_WORLD__])) !== null && _b !== void 0 ? _b : component._cst === 2) {
                        this.queryResult[i + 1] = component;
                    }
                    else {
                        continue outer;
                    }
                }
                return;
            }
            this.visitNextArchetype();
        }
    }
    /**
     * Create a Query with a given set of component types.
     *
     * @param selector Component makeup of entities
     */
    function query(...selector) {
        const pool = createStackPool(pool => new QueryIterable(selector, pool.release), q => {
            q.reset();
            return q;
        }, 100);
        return {
            [Symbol.iterator]() {
                return pool.retain().iterable;
            },
        };
    }

    function noop(...args) { }

    function mutableRemoveUnordered(arr, element) {
        const length = arr.length;
        const index = arr.indexOf(element);
        if (index === -1) {
            return false;
        }
        const last = arr.pop();
        if (index < length - 1) {
            arr[index] = last;
        }
        return true;
    }
    function mutableRemove(arr, element) {
        const index = arr.indexOf(element);
        if (index === -1) {
            return false;
        }
        arr.splice(index, 1);
        return true;
    }
    function mutableEmpty(arr) {
        while (arr.length > 0)
            arr.pop();
    }
    function arrayOf(len = 0, f = noop) {
        return Array(len)
            .fill(undefined)
            .map((_, i) => f(i));
    }

    const array = (type) => createDataType({
        name: "array",
        create(value = []) {
            return value;
        },
        reset(c, key, defaultValue) {
            if (typeof defaultValue !== "undefined") {
                c[key] = defaultValue.slice();
            }
            else {
                mutableEmpty(c[key]);
            }
        },
    });
    const number = createDataType({
        name: "number",
        create(value = 0) {
            return value;
        },
        reset(c, key, value = 0) {
            c[key] = value;
        },
    });
    const boolean = createDataType({
        name: "boolean",
        create(value = false) {
            return value;
        },
        reset(c, key, value = false) {
            c[key] = value;
        },
    });
    const string = createDataType({
        name: "string",
        create(value = "") {
            return value;
        },
        reset(c, key, value = "") {
            c[key] = value;
        },
    });

    const rMethod = /^\d+\(\)$/;
    const rInteger = /\d+/;
    let splitPathCache = {};
    function splitPath(path) {
        let splitPath = splitPathCache[path];
        if (!splitPath) {
            splitPath = path.split(".");
            for (let i = 0; i < splitPath.length; i++) {
                const pathComponent = splitPath[i];
                if (rInteger.test(pathComponent)) {
                    splitPath[i] = Number(pathComponent);
                }
            }
            splitPathCache[path] = splitPath;
        }
        return splitPath;
    }
    function applyMutation(root, path, value) {
        var _a;
        const arrPath = splitPath(path);
        const key = arrPath[arrPath.length - 1];
        let target = root;
        for (let i = 0; i < arrPath.length - 1; i++) {
            // @ts-ignore
            target = target[arrPath[i]];
        }
        const methodMatches = typeof key === "string" && key.match(rMethod);
        const methodType = methodMatches ? Number(methodMatches[0]) : null;
        if (typeof methodType === "number") {
            // @ts-ignore
            (_a = mutArrayMethodsByType
                .get(methodType)) === null || _a === void 0 ? void 0 : _a.apply(arrPath[arrPath.length - 2], value);
        }
        // @ts-ignore
        target[key] = value;
    }
    const isValidProxyTarget = (obj) => (typeof obj === "object" && obj !== null) || typeof obj === "function";
    var MutArrayMethodType;
    (function (MutArrayMethodType) {
        MutArrayMethodType[MutArrayMethodType["Push"] = 0] = "Push";
        MutArrayMethodType[MutArrayMethodType["Pop"] = 1] = "Pop";
        MutArrayMethodType[MutArrayMethodType["Shift"] = 2] = "Shift";
        MutArrayMethodType[MutArrayMethodType["Unshift"] = 3] = "Unshift";
        MutArrayMethodType[MutArrayMethodType["Splice"] = 4] = "Splice";
    })(MutArrayMethodType || (MutArrayMethodType = {}));
    const MUT_ARRAY_METHODS = new Map([
        [Array.prototype.push, MutArrayMethodType.Push],
        [Array.prototype.pop, MutArrayMethodType.Pop],
        [Array.prototype.shift, MutArrayMethodType.Shift],
        [Array.prototype.unshift, MutArrayMethodType.Unshift],
        [Array.prototype.splice, MutArrayMethodType.Splice],
    ]);
    const mutArrayMethodsByType = new Map([
        [MutArrayMethodType.Push, Array.prototype.push],
        [MutArrayMethodType.Pop, Array.prototype.pop],
        [MutArrayMethodType.Shift, Array.prototype.shift],
        [MutArrayMethodType.Unshift, Array.prototype.unshift],
        [MutArrayMethodType.Splice, Array.prototype.splice],
    ]);
    const ROOT_PATH = "";
    const createMutationCache = ({ onChange, }) => {
        const targetRoots = new WeakMap();
        const targetPaths = new WeakMap();
        const targetProxies = new WeakMap();
        const proxyTargetLookup = new WeakMap();
        const locked = new WeakSet();
        function getPath(target, key) {
            const basePath = targetPaths.get(target);
            if (basePath === ROOT_PATH) {
                return key.toString();
            }
            return `${basePath}.${key}`;
        }
        function getProxy(target, root = target, path = ROOT_PATH) {
            let proxy = targetProxies.get(target);
            if (proxy === undefined) {
                proxy = new Proxy(target, handler);
                targetProxies.set(target, proxy);
                proxyTargetLookup.set(proxy, target);
                targetRoots.set(target, root);
                targetPaths.set(target, path);
            }
            return proxy;
        }
        const handler = {
            get(target, propertyKey, receiver) {
                const value = Reflect.get(target, propertyKey, receiver);
                if (typeof propertyKey !== "symbol" && isValidProxyTarget(value)) {
                    return getProxy(value, targetRoots.get(target), getPath(target, propertyKey));
                }
                return value;
            },
            set(target, propertyKey, value, receiver) {
                const previous = target[propertyKey];
                target[propertyKey] = value;
                if (previous !== value &&
                    !locked.has(target) &&
                    typeof propertyKey !== "symbol") {
                    onChange(targetRoots.get(target), target, getPath(target, propertyKey), value);
                }
                return true;
            },
            apply(target, thisArgument, argumentsList) {
                const isArray = Array.isArray(thisArgument);
                const targetProxy = proxyTargetLookup.get(thisArgument);
                let mutArrayMethodType = MUT_ARRAY_METHODS.get(target);
                let hasMutArrayMethodType = isArray && typeof mutArrayMethodType === "number";
                if (hasMutArrayMethodType) {
                    locked.add(targetProxy);
                }
                const result = Reflect.apply(target, thisArgument, argumentsList);
                if (hasMutArrayMethodType) {
                    onChange(targetRoots.get(targetProxy), thisArgument, getPath(targetProxy, `${mutArrayMethodType}()`), argumentsList);
                    locked.delete(thisArgument);
                }
                return result;
            },
        };
        function revoke(target) {
            const proxy = targetProxies.get(target);
            targetProxies.delete(target);
            proxyTargetLookup.delete(proxy);
        }
        function proxy(target) {
            return getProxy(target);
        }
        return {
            proxy,
            revoke,
        };
    };

    function createStorage() {
        const mutationCache = createMutationCache({
            onChange(component, target, path, value, mutArrayMethodType) {
                let changes = mutations.get(component);
                if (!changes) {
                    changes = [];
                    mutations.set(component, changes);
                }
                if (mutArrayMethodType) {
                    changes.push(path, value, mutArrayMethodType);
                }
                else {
                    changes.push(path, value);
                }
            },
        });
        const mutations = new Map();
        const archetypes = [];
        // Array where the index corresponds to an entity and the value corresponds
        // to the index of the entity's archetype within the `archetypes` array. When
        // mutating or reading components, we always assume the location is valid
        // since it is kept in sync with the entity's archetype via the `create`,
        // `insert`, and `remove` methods.
        const archetypeIndicesByEntity = [];
        /**
         * Locate an archetype for a collection of components.
         *
         * @param components Components that archetype would contain
         */
        function findArchetype(components) {
            const len = components.length;
            for (let i = 0; i < archetypes.length; i++) {
                const archetype = archetypes[i];
                const { layout } = archetype;
                // Verify archetype has same number of components as predicate.
                if (layout.length !== len) {
                    continue;
                }
                let match = true;
                for (let j = 0; j < len; j++) {
                    // Affirm that archetype contains each component of predicate.
                    if (layout.indexOf(components[j]._tid) === -1) {
                        match = false;
                        break;
                    }
                }
                if (match) {
                    return archetype;
                }
            }
            return null;
        }
        /**
         * Locate or create an archetype for a collection of components.
         *
         * @param components Components that archetype would contain
         */
        function findOrCreateArchetype(components) {
            let archetype = findArchetype(components);
            if (!archetype) {
                archetype = createArchetype(components.map(c => c._tid));
                archetypes.push(archetype);
            }
            return archetype;
        }
        function create(entity, components) {
            const archetype = findOrCreateArchetype(components);
            archetype.insert(entity, components);
            archetypeIndicesByEntity[entity] = archetypes.indexOf(archetype);
            return entity;
        }
        function getEntityArchetype(entity) {
            const location = archetypeIndicesByEntity[entity];
            if (location === undefined) {
                throw new Error(`Failed to locate entity. Entity does not exist.`);
            }
            if (location === null) {
                throw new Error(`Failed to locate entity. Entity has been removed.`);
            }
            return archetypes[location];
        }
        function relocate(source, entity, components) {
            source.remove(entity);
            if (components.length === 0) {
                return;
            }
            const destination = findOrCreateArchetype(components);
            destination.insert(entity, components);
            archetypeIndicesByEntity[entity] = archetypes.indexOf(destination);
        }
        function insert(entity, components) {
            const source = getEntityArchetype(entity);
            const entityIndex = source.indices[entity];
            let destinationComponents = components.slice();
            for (let i = 0; i < source.layout.length; i++) {
                const componentTypeId = source.layout[i];
                if (components.find(c => c._tid === componentTypeId)) {
                    throw new Error(`Cannot attach component with type ${componentTypeId} â€” entity already has component of type.`);
                }
                // UNSAFE: `!` is used because entity location is non-null.
                destinationComponents.push(source.table[i][entityIndex]);
            }
            relocate(source, entity, destinationComponents);
        }
        function remove(entity, components) {
            const typesToRemove = components.map(component => component._tid);
            removeByTypeIds(entity, typesToRemove);
        }
        function removeByTypeIds(entity, componentTypeIds) {
            const source = getEntityArchetype(entity);
            const entityIndex = source.indices[entity];
            let destinationComponents = [];
            for (let i = 0; i < source.layout.length; i++) {
                const type = source.layout[i];
                const component = source.table[i][entityIndex];
                if (!componentTypeIds.includes(type)) {
                    destinationComponents.push(component);
                }
                else {
                    mutationCache.revoke(component);
                    mutations.delete(component);
                }
            }
            relocate(source, entity, destinationComponents);
        }
        function destroy(entity) {
            remove(entity, getComponentsOfEntity(entity));
            archetypeIndicesByEntity[entity] = null;
        }
        function patch(entity, componentTypeId, path, value) {
            const archetype = getEntityArchetype(entity);
            const entityIndex = archetype.indices[entity];
            const column = archetype.layoutInverse[componentTypeId];
            if (column === undefined) {
                return;
            }
            const target = getObservedComponent(archetype.table[column][entityIndex]);
            applyMutation(target, path, value);
        }
        const tmpComponentsToInsert = [];
        function upsert(entity, components) {
            const archetype = getEntityArchetype(entity);
            const entityIndex = archetype.indices[entity];
            mutableEmpty(tmpComponentsToInsert);
            for (let i = 0; i < components.length; i++) {
                const component = components[i];
                const column = archetype.layoutInverse[component._tid];
                if (column === undefined) {
                    // Entity component makeup does not match patch component, insert the new
                    // component.
                    tmpComponentsToInsert.push(component);
                }
                else {
                    const target = getObservedComponent(archetype.table[column][entityIndex]);
                    // Apply patch to component.
                    Object.assign(target, component);
                }
            }
            if (tmpComponentsToInsert.length > 0) {
                insert(entity, tmpComponentsToInsert);
            }
        }
        function findComponent(entity, componentType) {
            return findComponentByComponentTypeId(entity, componentType.type);
        }
        function findComponentByComponentTypeId(entity, componentTypeId) {
            const archetype = getEntityArchetype(entity);
            const column = archetype.layoutInverse[componentTypeId];
            if (column === undefined) {
                return null;
            }
            const entityIndex = archetype.indices[entity];
            // UNSAFE: `!` is used because entity location is non-null.
            return archetype.table[column][entityIndex];
        }
        function getComponentsOfEntity(entity) {
            const archetype = getEntityArchetype(entity);
            const entityIndex = archetype.indices[entity];
            const result = [];
            for (let i = 0; i < archetype.table.length; i++) {
                result.push(archetype.table[i][entityIndex]);
            }
            return result;
        }
        function clearMutations() {
            mutations.forEach(mutableEmpty);
        }
        function getMutationsOfComponent(component) {
            const changeSet = mutations.get(component);
            if (!changeSet) {
                throw new Error("ChangeSet does not exist for component.");
            }
            return changeSet;
        }
        function getObservedComponent(component) {
            return mutationCache.proxy(component);
        }
        function isComponentChanged(component) {
            const changeSet = mutations.get(component);
            return changeSet ? changeSet.length > 0 : false;
        }
        return {
            archetypes,
            clearMutations,
            create,
            destroy,
            findComponent,
            findComponentByComponentTypeId,
            getComponentMutations: getMutationsOfComponent,
            getEntityComponents: getComponentsOfEntity,
            getObservedComponent,
            insert,
            isComponentChanged,
            patch,
            remove,
            removeByTypeIds,
            upsert,
        };
    }

    /**
     * The utility method used to create a topic, consumes a type parameter
     * and a name and returns an object that conforms to the topic type
     */
    const createTopic = () => {
        const staged = [];
        const ready = [];
        const push = (event) => staged.push(event);
        const pushImmediate = (event) => ready.push(event);
        const flush = () => {
            mutableEmpty(ready);
            const len = staged.length;
            for (let i = len - 1; i >= 0; i--) {
                ready[i] = staged.pop();
            }
        };
        return {
            *[Symbol.iterator]() {
                for (let i = 0; i < ready.length; i++) {
                    yield ready[i];
                }
            },
            push,
            pushImmediate,
            flush,
        };
    };

    (function (WorldOpType) {
        WorldOpType[WorldOpType["Spawn"] = 0] = "Spawn";
        WorldOpType[WorldOpType["Attach"] = 1] = "Attach";
        WorldOpType[WorldOpType["Detach"] = 2] = "Detach";
        WorldOpType[WorldOpType["Mutate"] = 3] = "Mutate";
        WorldOpType[WorldOpType["Destroy"] = 4] = "Destroy";
    })(exports.WorldOpType || (exports.WorldOpType = {}));

    const createWorld = (options = {}) => {
        const { systems = [], componentPoolSize = 1000 } = options;
        const worldOps = [];
        const worldOpsPrevious = [];
        const worldOpPool = createStackPool(() => [], op => {
            mutableEmpty(op);
            return op;
        }, 1000);
        const componentPoolsByComponentTypeId = new Map();
        const storage = createStorage();
        const componentTypes = [];
        const destroyed = new Set();
        const detached = new Map();
        const attaching = [];
        const state = {
            currentTickData: null,
            currentTick: 0,
        };
        let entityCounter = 0;
        function applySpawnOp(op) {
            const [, entity, components] = op;
            flagComponents(components, exports.ComponentState.Attaching);
            attaching.push(components);
            storage.create(entity, components);
        }
        function applyAttachOp(op) {
            const [, entity, components] = op;
            flagComponents(components, exports.ComponentState.Attaching);
            attaching.push(components);
            storage.insert(entity, components);
        }
        function applyDetachOp(op) {
            const [, entity, componentTypeIds] = op;
            for (let i = 0; i < componentTypeIds.length; i++) {
                const component = storage.findComponentByComponentTypeId(entity, componentTypeIds[i]);
                flagComponent(component, exports.ComponentState.Detached);
            }
            detached.set(entity, componentTypeIds);
        }
        function applyDestroyOp(op) {
            const [, entity] = op;
            const components = storage.getEntityComponents(entity);
            flagComponents(components, exports.ComponentState.Detached);
            destroyed.add(entity);
        }
        function applyWorldOp(worldOp, record = true) {
            if (record === true) {
                worldOpsPrevious.push(worldOp);
            }
            switch (worldOp[0]) {
                case exports.WorldOpType.Spawn:
                    return applySpawnOp(worldOp);
                case exports.WorldOpType.Attach:
                    return applyAttachOp(worldOp);
                case exports.WorldOpType.Detach:
                    return applyDetachOp(worldOp);
                case exports.WorldOpType.Destroy:
                    return applyDestroyOp(worldOp);
            }
        }
        function maybeReleaseComponent(component) {
            const pool = componentPoolsByComponentTypeId.get(component._tid);
            if (pool) {
                pool.release(component);
            }
        }
        function finalDestroy(entity) {
            storage.getEntityComponents(entity).forEach(maybeReleaseComponent);
            storage.destroy(entity);
        }
        function finalDetach(componentTypeIds, entity) {
            for (let i = 0; i < componentTypeIds.length; i++) {
                const component = storage.findComponentByComponentTypeId(entity, componentTypeIds[i]);
                maybeReleaseComponent(component);
            }
            storage.removeByTypeIds(entity, componentTypeIds);
        }
        function maintain() {
            // Clear change cache
            storage.clearMutations();
            // Clear world op history
            while (worldOpsPrevious.length > 0) {
                worldOpPool.release(worldOpsPrevious.pop());
            }
            while (attaching.length > 0) {
                flagComponents(attaching.pop(), exports.ComponentState.Attached);
            }
            detached.forEach(finalDetach);
            detached.clear();
            destroyed.forEach(finalDestroy);
            destroyed.clear();
            while (worldOps.length > 0) {
                applyWorldOp(worldOps.pop());
            }
        }
        function tick(data) {
            globals.__CURRENT_WORLD__ = id;
            state.currentTickData = data;
            if (state.currentTick === 0) {
                maintain();
            }
            maintain();
            // Execute systems
            for (let i = 0; i < systems.length; i++) {
                globals.__CURRENT_SYSTEM__ = i;
                systems[i](world);
            }
            state.currentTick++;
        }
        function addSystem(system) {
            systems.push(system);
        }
        function removeSystem(system) {
            const index = systems.indexOf(system);
            if (index > -1) {
                systems.splice(index, 1);
            }
        }
        function component(componentType, ...args) {
            const componentTypeHasBeenRegistered = componentTypes.includes(componentType);
            if (!componentTypeHasBeenRegistered) {
                registerComponentType(componentType);
            }
            const pool = componentPoolsByComponentTypeId.get(componentType.type);
            const component = pool.retain();
            if (componentType.initialize) {
                componentType.initialize(component, ...args);
            }
            return component;
        }
        function createOp(...args) {
            const worldOp = worldOpPool.retain();
            for (let i = 0; i < args.length; i++) {
                worldOp[i] = args[i];
            }
            return worldOp;
        }
        function spawn(...components) {
            const entity = entityCounter++;
            const worldOp = createOp(exports.WorldOpType.Spawn, entity, components);
            worldOps.push(worldOp);
            return entity;
        }
        function attach(entity, ...components) {
            const op = createOp(exports.WorldOpType.Attach, entity, components);
            worldOps.push(op);
        }
        function detach(entity, ...components) {
            const componentTypeIds = components.map(c => c._tid);
            const worldOp = createOp(exports.WorldOpType.Detach, entity, componentTypeIds);
            flagComponents(components, exports.ComponentState.Detaching);
            worldOps.push(worldOp);
        }
        function destroy(entity) {
            const worldOp = createOp(exports.WorldOpType.Destroy, entity);
            const components = storage.getEntityComponents(entity);
            flagComponents(components, exports.ComponentState.Detaching);
            worldOps.push(worldOp);
        }
        function applyOps(opsToApply) {
            for (let i = 0; i < opsToApply.length; i++) {
                const op = opsToApply[i];
                switch (op[0]) {
                    case exports.WorldOpType.Detach: {
                        const [, entity, componentTypeIds] = op;
                        const components = componentTypeIds.map(componentTypeId => storage.findComponentByComponentTypeId(entity, componentTypeId));
                        for (let j = 0; j < components.length; j++) {
                            const component = components[j];
                            if (component) {
                                flagComponent(component, exports.ComponentState.Detaching);
                            }
                        }
                        break;
                    }
                    case exports.WorldOpType.Destroy: {
                        const [, entity] = op;
                        const components = storage.getEntityComponents(entity);
                        flagComponents(components, exports.ComponentState.Detaching);
                        break;
                    }
                }
                applyWorldOp(op, false);
            }
        }
        function getComponent(entity, componentType) {
            const component = storage.findComponent(entity, componentType);
            if (component === null) {
                throw new Error("Component not found");
            }
            return component;
        }
        function tryGetComponent(entity, componentType) {
            return storage.findComponent(entity, componentType);
        }
        function registerComponentType(componentType, poolSize = componentPoolSize) {
            const registeredComponentTypeWithTypeId = componentTypes.find(({ type }) => componentType.type === type);
            if (registeredComponentTypeWithTypeId) {
                throw new Error(`Tried to register componentType with type id ${componentType.type} more than once.`);
            }
            componentTypes.push(componentType);
            componentPoolsByComponentTypeId.set(componentType.type, createComponentPool(componentType, poolSize));
        }
        const { getObservedComponent, isComponentChanged, patch } = storage;
        const world = {
            addSystem,
            applyOps,
            attach,
            component,
            componentTypes,
            destroy,
            detach,
            getComponent,
            getObservedComponent,
            id: -1,
            isComponentChanged,
            ops: worldOpsPrevious,
            patch,
            removeSystem,
            state,
            spawn,
            storage,
            tick,
            tryGetComponent,
        };
        let id = (world.id = globals.__WORLDS__.push(world) - 1);
        return world;
    };

    exports.$isDataType = $isDataType;
    exports.array = array;
    exports.arrayOf = arrayOf;
    exports.attached = attached;
    exports.boolean = boolean;
    exports.changed = changed;
    exports.createArchetype = createArchetype;
    exports.createComponentBase = createComponentBase;
    exports.createComponentFilter = createComponentFilter;
    exports.createComponentPool = createComponentPool;
    exports.createComponentType = createComponentType;
    exports.createDataType = createDataType;
    exports.createEffect = createEffect;
    exports.createStorage = createStorage;
    exports.createTopic = createTopic;
    exports.createWorld = createWorld;
    exports.detached = detached;
    exports.flagComponent = flagComponent;
    exports.flagComponents = flagComponents;
    exports.initializeComponentFromSchema = initializeComponentFromSchema;
    exports.isComponentOf = isComponentOf;
    exports.isDataType = isDataType;
    exports.mutableEmpty = mutableEmpty;
    exports.mutableRemove = mutableRemove;
    exports.mutableRemoveUnordered = mutableRemoveUnordered;
    exports.noop = noop;
    exports.number = number;
    exports.query = query;
    exports.resetComponentFromSchema = resetComponentFromSchema;
    exports.string = string;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
