;(function (global, factory) {
  typeof exports === "object" && typeof module !== "undefined"
    ? factory(exports)
    : typeof define === "function" && define.amd
    ? define(["exports"], factory)
    : ((global =
        typeof globalThis !== "undefined" ? globalThis : global || self),
      factory((global.Javelin = {})))
})(this, function (exports) {
  "use strict"

  /**
   * Create an Archetype.
   *
   * @param layout Array of component types that make up the archetype
   */
  function createArchetype(layout) {
    const len = layout.length
    const table = []
    const entities = []
    const indices = []
    const layoutInverse = layout.reduce((a, x, i) => {
      a[x] = i
      return a
    }, [])
    // Initialize the table with an empty collection of components for each
    // component type.
    for (let i = 0; i < len; i++) {
      table[i] = []
    }
    function insert(entity, components) {
      for (let i = 0; i < components.length; i++) {
        const component = components[i]
        const componentTypeIndex = layoutInverse[component.tid]
        table[componentTypeIndex].push(component)
      }
      indices[entity] = entities.push(entity) - 1
    }
    function remove(entity) {
      const length = entities.length
      const index = indices[entity]
      const head = entities.pop()
      indices[entity] = -1
      if (index === length - 1) {
        for (const column of table) column.pop()
        return
      }
      // Move leading entity's components to removed index position
      for (const column of table) {
        column[index] = column.pop()
      }
      // Move leading entity to removed index position
      entities[index] = head
      // Update previously leading entity's index
      indices[head] = index
    }
    return {
      layout,
      layoutInverse,
      table,
      indices,
      entities,
      insert,
      remove,
    }
  }

  ;(function (ComponentState) {
    ComponentState[(ComponentState["Orphaned"] = 0)] = "Orphaned"
    ComponentState[(ComponentState["Attaching"] = 1)] = "Attaching"
    ComponentState[(ComponentState["Attached"] = 2)] = "Attached"
    ComponentState[(ComponentState["Detaching"] = 3)] = "Detaching"
    ComponentState[(ComponentState["Detached"] = 4)] = "Detached"
  })(exports.ComponentState || (exports.ComponentState = {}))

  function createComponentFilter(getPredicate) {
    return componentType => ({
      componentType,
      componentPredicate: getPredicate(),
    })
  }

  const attached = createComponentFilter(() => ({ _cst }) =>
    _cst === exports.ComponentState.Attaching,
  )

  const changed = createComponentFilter(() => (c, { isComponentChanged }) =>
    isComponentChanged(c),
  )

  const detached = createComponentFilter(() => ({ _cst }) =>
    _cst === exports.ComponentState.Detached,
  )

  function createStackPool(type, reset, size) {
    const heap = []
    const allocate = () => {
      for (let i = 0; i < size; i++) {
        heap.push(type())
      }
    }
    const retain = () => {
      if (!heap.length) {
        allocate()
      }
      return heap.pop()
    }
    const release = obj => {
      heap.push(reset(obj))
    }
    return {
      allocate,
      retain,
      release,
    }
  }

  const $isDataType = Symbol("is_data_type")

  function createDataType(config) {
    return { ...config, [$isDataType]: true }
  }
  function isDataType(obj) {
    return typeof obj === "object" && obj !== null && obj[$isDataType]
  }
  function initializeComponentFromSchema(component, schema) {
    for (const prop in schema) {
      const value = schema[prop]
      if (isDataType(value)) {
        // DataType
        component[prop] = value.create(undefined)
      } else if ("type" in value && isDataType(value.type)) {
        // DataType with defaultValue
        const { type, defaultValue } = value
        component[prop] = type.create(defaultValue)
      } else {
        // Schema
        initializeComponentFromSchema(component, value)
      }
    }
    return component
  }
  function resetComponentFromSchema(component, schema) {
    component.cst = exports.ComponentState.Orphaned
    for (const prop in schema) {
      const value = schema[prop]
      if (isDataType(value)) {
        // DataType
        value.reset(component, prop, undefined)
      } else if ("type" in value && isDataType(value.type)) {
        // DataType with defaultValue
        const { type, defaultValue } = value
        type.reset(component, prop, defaultValue)
      } else {
        // Schema
        resetComponentFromSchema(component, value)
      }
    }
    return component
  }

  function createComponentType(componentType) {
    return componentType
  }
  function createComponentBase(componentType) {
    return Object.defineProperties(
      {},
      {
        _tid: { value: componentType.type, writable: false, enumerable: true },
        _cst: {
          value: exports.ComponentState.Orphaned,
          writable: true,
          enumerable: false,
        },
      },
    )
  }
  function createComponentPool(componentType, poolSize) {
    const componentPool = createStackPool(
      () =>
        initializeComponentFromSchema(
          createComponentBase(componentType),
          componentType.schema,
        ),
      c => resetComponentFromSchema(c, componentType.schema),
      poolSize,
    )
    return componentPool
  }
  function isComponentOf(component, componentTypeId) {
    return component.tid === componentTypeId.type
  }
  function flagComponent(component, state) {
    component.cst = state
  }
  function flagComponents(components, state) {
    for (let i = 0; i < components.length; i++) {
      components[i].cst = state
    }
  }

  function noop(...args) {}

  function mutableRemoveUnordered(arr, element) {
    const length = arr.length
    const index = arr.indexOf(element)
    if (index === -1) {
      return false
    }
    const last = arr.pop()
    if (index < length - 1) {
      arr[index] = last
    }
    return true
  }
  function mutableRemove(arr, element) {
    const index = arr.indexOf(element)
    if (index === -1) {
      return false
    }
    arr.splice(index, 1)
    return true
  }
  function mutableEmpty(arr) {
    while (arr.length > 0) arr.pop()
  }
  function arrayOf(len = 0, f = noop) {
    return Array(len)
      .fill(undefined)
      .map((_, i) => f(i))
  }

  class QueryIterable {
    constructor(selector) {
      this.queryLength = -1
      this.queryLayout = []
      this.componentFilterPredicates = []
      this.queryResult = [-1, []]
      this.readIndices = []
      this.onDone = null
      this._onDone = () => this.onDone(this)
      // iterator state
      this.world = null
      this.entityIndex = -1
      this.archetypeIndex = -1
      this.currentArchetype = null
      this.next = () => {
        if (this.currentArchetype === null) {
          this.visitNextArchetype()
        } else {
          this.visitNextEntity()
        }
        return this.iteratorResult
      }
      this.componentFilterPredicates = selector.map(s =>
        "componentPredicate" in s ? s.componentPredicate : null,
      )
      this.queryLayout = selector.map(s =>
        "componentType" in s ? s.componentType.type : s.type,
      )
      this.queryLength = selector.length
      this.iterable = {
        next: this.next,
      }
      this.iteratorResult = {
        value: this.queryResult,
        done: false,
      }
    }
    reset() {
      this.entityIndex = -1
      this.archetypeIndex = -1
      this.currentArchetype = null
      this.queryResult[0] = -1
      this.iteratorResult.done = false
      mutableEmpty(this.queryResult[1]) // might not be necessary
    }
    visitNextArchetype() {
      const { queryLayout, queryLength, readIndices, world } = this
      outer: while (
        (this.currentArchetype =
          world.storage.archetypes[++this.archetypeIndex])
      ) {
        const { layoutInverse } = this.currentArchetype
        for (let i = 0; i < queryLength; i++) {
          const index = layoutInverse[queryLayout[i]]
          if (index === undefined) {
            continue outer
          }
          readIndices[i] = index
        }
        this.entityIndex = -1
        this.visitNextEntity()
        return
      }
      this.iteratorResult.done = true
      setTimeout(this._onDone)
    }
    visitNextEntity() {
      var _a, _b
      const {
        currentArchetype,
        readIndices,
        componentFilterPredicates,
        world,
      } = this
      const { table, entities } = currentArchetype
      const length = entities.length
      outer: while (++this.entityIndex < length) {
        this.queryResult[0] = entities[this.entityIndex]
        for (let i = 0; i < this.queryLength; i++) {
          const component = table[readIndices[i]][this.entityIndex]
          if (
            (_b =
              (_a = componentFilterPredicates[i]) === null || _a === void 0
                ? void 0
                : _a.call(componentFilterPredicates, component, world)) !==
              null && _b !== void 0
              ? _b
              : component.cst === 2
          ) {
            this.queryResult[1][i] = component
          } else {
            continue outer
          }
        }
        return
      }
      this.visitNextArchetype()
    }
    [Symbol.iterator]() {
      return this.iterable
    }
    init(world, onDone) {
      this.reset()
      this.world = world
      this.onDone = onDone
    }
  }
  /**
   * Create a Query with a given set of component types.
   *
   * @param selector Component makeup of entities
   */
  function query(...selector) {
    const pool = createStackPool(
      () => new QueryIterable(selector),
      q => {
        q.reset()
        return q
      },
      100,
    )
    return world => {
      const query = pool.retain()
      query.init(world, pool.release)
      return query
    }
  }

  const array = type =>
    createDataType({
      name: "array",
      create(value = []) {
        return value
      },
      reset(c, key, defaultValue) {
        if (typeof defaultValue !== "undefined") {
          c[key] = defaultValue.slice()
        } else {
          mutableEmpty(c[key])
        }
      },
    })
  const number = createDataType({
    name: "number",
    create(value = 0) {
      return value
    },
    reset(c, key, value = 0) {
      c[key] = value
    },
  })
  const boolean = createDataType({
    name: "boolean",
    create(value = false) {
      return value
    },
    reset(c, key, value = false) {
      c[key] = value
    },
  })
  const string = createDataType({
    name: "string",
    create(value = "") {
      return value
    },
    reset(c, key, value = "") {
      c[key] = value
    },
  })

  const rMethod = /^\d+\(\)$/
  const rInteger = /\d+/
  let splitPathCache = {}
  function splitPath(path) {
    let splitPath = splitPathCache[path]
    if (!splitPath) {
      splitPath = path.split(".")
      for (let i = 0; i < splitPath.length; i++) {
        const pathComponent = splitPath[i]
        if (rInteger.test(pathComponent)) {
          splitPath[i] = Number(pathComponent)
        }
      }
      splitPathCache[path] = splitPath
    }
    return splitPath
  }
  function applyMutation(root, path, value) {
    var _a
    const arrPath = splitPath(path)
    const key = arrPath[arrPath.length - 1]
    let target = root
    for (let i = 0; i < arrPath.length - 1; i++) {
      // @ts-ignore
      target = target[arrPath[i]]
    }
    const methodMatches = typeof key === "string" && key.match(rMethod)
    const methodType = methodMatches ? Number(methodMatches[0]) : null
    if (typeof methodType === "number") {
      // @ts-ignore
      ;(_a = mutArrayMethodsByType.get(methodType)) === null || _a === void 0
        ? void 0
        : _a.apply(arrPath[arrPath.length - 2], value)
    }
    // @ts-ignore
    target[key] = value
  }
  const isValidProxyTarget = obj =>
    (typeof obj === "object" && obj !== null) || typeof obj === "function"
  var MutArrayMethodType
  ;(function (MutArrayMethodType) {
    MutArrayMethodType[(MutArrayMethodType["Push"] = 0)] = "Push"
    MutArrayMethodType[(MutArrayMethodType["Pop"] = 1)] = "Pop"
    MutArrayMethodType[(MutArrayMethodType["Shift"] = 2)] = "Shift"
    MutArrayMethodType[(MutArrayMethodType["Unshift"] = 3)] = "Unshift"
    MutArrayMethodType[(MutArrayMethodType["Splice"] = 4)] = "Splice"
  })(MutArrayMethodType || (MutArrayMethodType = {}))
  const MUT_ARRAY_METHODS = new Map([
    [Array.prototype.push, MutArrayMethodType.Push],
    [Array.prototype.pop, MutArrayMethodType.Pop],
    [Array.prototype.shift, MutArrayMethodType.Shift],
    [Array.prototype.unshift, MutArrayMethodType.Unshift],
    [Array.prototype.splice, MutArrayMethodType.Splice],
  ])
  const mutArrayMethodsByType = new Map([
    [MutArrayMethodType.Push, Array.prototype.push],
    [MutArrayMethodType.Pop, Array.prototype.pop],
    [MutArrayMethodType.Shift, Array.prototype.shift],
    [MutArrayMethodType.Unshift, Array.prototype.unshift],
    [MutArrayMethodType.Splice, Array.prototype.splice],
  ])
  const ROOT_PATH = ""
  const createMutationCache = ({ onChange }) => {
    const targetRoots = new WeakMap()
    const targetPaths = new WeakMap()
    const targetProxies = new WeakMap()
    const proxyTargetLookup = new WeakMap()
    const locked = new WeakSet()
    function getPath(target, key) {
      const basePath = targetPaths.get(target)
      if (basePath === ROOT_PATH) {
        return key.toString()
      }
      return `${basePath}.${key}`
    }
    function getProxy(target, root = target, path = ROOT_PATH) {
      let proxy = targetProxies.get(target)
      if (proxy === undefined) {
        proxy = new Proxy(target, handler)
        targetProxies.set(target, proxy)
        proxyTargetLookup.set(proxy, target)
        targetRoots.set(target, root)
        targetPaths.set(target, path)
      }
      return proxy
    }
    const handler = {
      get(target, propertyKey, receiver) {
        const value = Reflect.get(target, propertyKey, receiver)
        if (typeof propertyKey !== "symbol" && isValidProxyTarget(value)) {
          return getProxy(
            value,
            targetRoots.get(target),
            getPath(target, propertyKey),
          )
        }
        return value
      },
      set(target, propertyKey, value, receiver) {
        const previous = target[propertyKey]
        target[propertyKey] = value
        if (previous !== value && !locked.has(target)) {
          onChange(
            targetRoots.get(target),
            target,
            getPath(target, propertyKey),
            value,
          )
        }
        return true
      },
      apply(target, thisArgument, argumentsList) {
        const isArray = Array.isArray(thisArgument)
        const targetProxy = proxyTargetLookup.get(thisArgument)
        let mutArrayMethodType = MUT_ARRAY_METHODS.get(target)
        let hasMutArrayMethodType =
          isArray && typeof mutArrayMethodType === "number"
        if (hasMutArrayMethodType) {
          locked.add(targetProxy)
        }
        const result = Reflect.apply(target, thisArgument, argumentsList)
        if (hasMutArrayMethodType) {
          onChange(
            targetRoots.get(targetProxy),
            thisArgument,
            getPath(targetProxy, `${mutArrayMethodType}()`),
            argumentsList,
          )
          locked.delete(thisArgument)
        }
        return result
      },
    }
    function revoke(target) {
      const proxy = targetProxies.get(target)
      targetProxies.delete(target)
      proxyTargetLookup.delete(proxy)
    }
    function proxy(target) {
      return getProxy(target)
    }
    return {
      proxy,
      revoke,
    }
  }

  function createStorage() {
    const mutationCache = createMutationCache({
      onChange(component, target, path, value, mutArrayMethodType) {
        let changes = mutations.get(component)
        if (!changes) {
          changes = []
          mutations.set(component, changes)
        }
        if (mutArrayMethodType) {
          changes.push(path, value, mutArrayMethodType)
        } else {
          changes.push(path, value)
        }
      },
    })
    const mutations = new Map()
    const archetypes = []
    // Array where the index corresponds to an entity and the value corresponds
    // to the index of the entity's archetype within the `archetypes` array. When
    // mutating or reading components, we always assume the location is valid
    // since it is kept in sync with the entity's archetype via the `create`,
    // `insert`, and `remove` methods.
    const archetypeIndicesByEntity = []
    /**
     * Locate an archetype for a collection of components.
     *
     * @param components Components that archetype would contain
     */
    function findArchetype(components) {
      const len = components.length
      for (let i = 0; i < archetypes.length; i++) {
        const archetype = archetypes[i]
        const { layout } = archetype
        // Verify archetype has same number of components as predicate.
        if (layout.length !== len) {
          continue
        }
        let match = true
        for (let j = 0; j < len; j++) {
          // Affirm that archetype contains each component of predicate.
          if (layout.indexOf(components[j].tid) === -1) {
            match = false
            break
          }
        }
        if (match) {
          return archetype
        }
      }
      return null
    }
    /**
     * Locate or create an archetype for a collection of components.
     *
     * @param components Components that archetype would contain
     */
    function findOrCreateArchetype(components) {
      let archetype = findArchetype(components)
      if (!archetype) {
        archetype = createArchetype(components.map(c => c.tid))
        archetypes.push(archetype)
      }
      return archetype
    }
    function create(entity, components) {
      const archetype = findOrCreateArchetype(components)
      archetype.insert(entity, components)
      archetypeIndicesByEntity[entity] = archetypes.indexOf(archetype)
      return entity
    }
    function getEntityArchetype(entity) {
      const location = archetypeIndicesByEntity[entity]
      if (location === undefined) {
        throw new Error(`Failed to locate entity. Entity does not exist.`)
      }
      if (location === null) {
        throw new Error(`Failed to locate entity. Entity has been removed.`)
      }
      return archetypes[location]
    }
    function relocate(source, entity, components) {
      source.remove(entity)
      if (components.length === 0) {
        return
      }
      const destination = findOrCreateArchetype(components)
      destination.insert(entity, components)
      archetypeIndicesByEntity[entity] = archetypes.indexOf(destination)
    }
    function insert(entity, components) {
      const source = getEntityArchetype(entity)
      const entityIndex = source.indices[entity]
      let destinationComponents = components.slice()
      for (let i = 0; i < source.layout.length; i++) {
        const componentTypeId = source.layout[i]
        if (components.find(c => c.tid === componentTypeId)) {
          throw new Error(
            `Cannot attach component with type ${componentTypeId} — entity already has component of type.`,
          )
        }
        // UNSAFE: `!` is used because entity location is non-null.
        destinationComponents.push(source.table[i][entityIndex])
      }
      relocate(source, entity, destinationComponents)
    }
    function remove(entity, components) {
      const typesToRemove = components.map(component => component.tid)
      removeByTypeIds(entity, typesToRemove)
    }
    function removeByTypeIds(entity, componentTypeIds) {
      const source = getEntityArchetype(entity)
      const entityIndex = source.indices[entity]
      let destinationComponents = []
      for (let i = 0; i < source.layout.length; i++) {
        const type = source.layout[i]
        const component = source.table[i][entityIndex]
        if (!componentTypeIds.includes(type)) {
          destinationComponents.push(component)
        } else {
          mutationCache.revoke(component)
          mutations.delete(component)
        }
      }
      relocate(source, entity, destinationComponents)
    }
    function destroy(entity) {
      remove(entity, getComponentsOfEntity(entity))
      archetypeIndicesByEntity[entity] = null
    }
    function patch(entity, componentTypeId, path, value) {
      const archetype = getEntityArchetype(entity)
      const entityIndex = archetype.indices[entity]
      const column = archetype.layoutInverse[componentTypeId]
      if (column === undefined) {
        return
      }
      const target = getObservedComponent(archetype.table[column][entityIndex])
      applyMutation(target, path, value)
    }
    const tmpComponentsToInsert = []
    function upsert(entity, components) {
      const archetype = getEntityArchetype(entity)
      const entityIndex = archetype.indices[entity]
      mutableEmpty(tmpComponentsToInsert)
      for (let i = 0; i < components.length; i++) {
        const component = components[i]
        const column = archetype.layoutInverse[component.tid]
        if (column === undefined) {
          // Entity component makeup does not match patch component, insert the new
          // component.
          tmpComponentsToInsert.push(component)
        } else {
          const target = getObservedComponent(
            archetype.table[column][entityIndex],
          )
          // Apply patch to component.
          Object.assign(target, component)
        }
      }
      if (tmpComponentsToInsert.length > 0) {
        insert(entity, tmpComponentsToInsert)
      }
    }
    function findComponent(entity, componentType) {
      return findComponentByComponentTypeId(entity, componentType.type)
    }
    function findComponentByComponentTypeId(entity, componentTypeId) {
      const archetype = getEntityArchetype(entity)
      const column = archetype.layoutInverse[componentTypeId]
      if (column === undefined) {
        return null
      }
      const entityIndex = archetype.indices[entity]
      // UNSAFE: `!` is used because entity location is non-null.
      return archetype.table[column][entityIndex]
    }
    function getComponentsOfEntity(entity) {
      const archetype = getEntityArchetype(entity)
      const entityIndex = archetype.indices[entity]
      const result = []
      for (let i = 0; i < archetype.table.length; i++) {
        result.push(archetype.table[i][entityIndex])
      }
      return result
    }
    function clearMutations() {
      mutations.forEach(mutableEmpty)
    }
    function getMutationsOfComponent(component) {
      const changeSet = mutations.get(component)
      if (!changeSet) {
        throw new Error("ChangeSet does not exist for component.")
      }
      return changeSet
    }
    function getObservedComponent(component) {
      return mutationCache.proxy(component)
    }
    function isComponentChanged(component) {
      const changeSet = mutations.get(component)
      return changeSet ? changeSet.length > 0 : false
    }
    return {
      archetypes,
      clearMutations,
      create,
      destroy,
      findComponent,
      findComponentByComponentTypeId,
      getComponentMutations: getMutationsOfComponent,
      getEntityComponents: getComponentsOfEntity,
      getObservedComponent,
      insert,
      isComponentChanged,
      patch,
      remove,
      removeByTypeIds,
      upsert,
    }
  }

  /**
   * The utility method used to create a topic, consumes a type parameter
   * and a name and returns an object that conforms to the topic type
   */
  const createTopic = () => {
    const staged = []
    const ready = []
    const push = event => staged.push(event)
    const pushImmediate = event => ready.push(event)
    const flush = () => {
      mutableEmpty(ready)
      const len = staged.length
      for (let i = len - 1; i >= 0; i--) {
        ready[i] = staged.pop()
      }
    }
    return {
      *[Symbol.iterator]() {
        for (let i = 0; i < ready.length; i++) {
          yield ready[i]
        }
      },
      push,
      pushImmediate,
      flush,
    }
  }

  ;(function (WorldOpType) {
    WorldOpType[(WorldOpType["Spawn"] = 0)] = "Spawn"
    WorldOpType[(WorldOpType["Attach"] = 1)] = "Attach"
    WorldOpType[(WorldOpType["Detach"] = 2)] = "Detach"
    WorldOpType[(WorldOpType["Mutate"] = 3)] = "Mutate"
    WorldOpType[(WorldOpType["Destroy"] = 4)] = "Destroy"
  })(exports.WorldOpType || (exports.WorldOpType = {}))

  const createWorld = (options = {}) => {
    const { systems = [], componentPoolSize = 1000 } = options
    const worldOps = []
    const worldOpsPrevious = []
    const worldOpPool = createStackPool(
      () => [],
      op => {
        mutableEmpty(op)
        return op
      },
      1000,
    )
    const componentPoolsByComponentTypeId = new Map()
    const storage = createStorage()
    const componentTypes = []
    const destroyed = new Set()
    const detached = new Map()
    const attaching = []
    let currentTick = 0
    let entityCounter = 0
    function applySpawnOp(op) {
      const [, entity, components] = op
      flagComponents(components, exports.ComponentState.Attaching)
      attaching.push(components)
      storage.create(entity, components)
    }
    function applyAttachOp(op) {
      const [, entity, components] = op
      flagComponents(components, exports.ComponentState.Attaching)
      attaching.push(components)
      storage.insert(entity, components)
    }
    function applyDetachOp(op) {
      const [, entity, componentTypeIds] = op
      for (let i = 0; i < componentTypeIds.length; i++) {
        const component = storage.findComponentByComponentTypeId(
          entity,
          componentTypeIds[i],
        )
        flagComponent(component, exports.ComponentState.Detached)
      }
      detached.set(entity, componentTypeIds)
    }
    function applyDestroyOp(op) {
      const [, entity] = op
      const components = storage.getEntityComponents(entity)
      flagComponents(components, exports.ComponentState.Detached)
      destroyed.add(entity)
    }
    function applyWorldOp(worldOp) {
      worldOpsPrevious.push(worldOp)
      switch (worldOp[0]) {
        case exports.WorldOpType.Spawn:
          return applySpawnOp(worldOp)
        case exports.WorldOpType.Attach:
          return applyAttachOp(worldOp)
        case exports.WorldOpType.Detach:
          return applyDetachOp(worldOp)
        case exports.WorldOpType.Destroy:
          return applyDestroyOp(worldOp)
      }
    }
    function maybeReleaseComponent(component) {
      const pool = componentPoolsByComponentTypeId.get(component.tid)
      if (pool) {
        pool.release(component)
      }
    }
    function finalDestroy(entity) {
      storage.getEntityComponents(entity).forEach(maybeReleaseComponent)
      storage.destroy(entity)
    }
    function finalDetach(componentTypeIds, entity) {
      for (let i = 0; i < componentTypeIds.length; i++) {
        const component = storage.findComponentByComponentTypeId(
          entity,
          componentTypeIds[i],
        )
        maybeReleaseComponent(component)
      }
      storage.removeByTypeIds(entity, componentTypeIds)
    }
    function maintain() {
      // Clear change cache
      storage.clearMutations()
      // Clear world op history
      while (worldOpsPrevious.length > 0) {
        worldOpPool.release(worldOpsPrevious.pop())
      }
      while (attaching.length > 0) {
        flagComponents(attaching.pop(), exports.ComponentState.Attached)
      }
      detached.forEach(finalDetach)
      detached.clear()
      destroyed.forEach(finalDestroy)
      destroyed.clear()
      while (worldOps.length > 0) {
        applyWorldOp(worldOps.pop())
      }
    }
    function tick(data) {
      if (currentTick === 0) {
        maintain()
      }
      maintain()
      // Execute systems
      for (let i = 0; i < systems.length; i++) {
        systems[i](world, data)
      }
      currentTick++
    }
    function addSystem(system) {
      systems.push(system)
    }
    function removeSystem(system) {
      const index = systems.indexOf(system)
      if (index > -1) {
        systems.splice(index, 1)
      }
    }
    function component(componentType, ...args) {
      const componentTypeHasBeenRegistered = componentTypes.includes(
        componentType,
      )
      if (!componentTypeHasBeenRegistered) {
        registerComponentType(componentType)
      }
      const pool = componentPoolsByComponentTypeId.get(componentType.type)
      const component = pool.retain()
      if (componentType.initialize) {
        componentType.initialize(component, ...args)
      }
      return component
    }
    function createOp(...args) {
      const worldOp = worldOpPool.retain()
      for (let i = 0; i < args.length; i++) {
        worldOp[i] = args[i]
      }
      return worldOp
    }
    function spawn(...components) {
      const entity = entityCounter++
      const worldOp = createOp(exports.WorldOpType.Spawn, entity, components)
      worldOps.push(worldOp)
      return entity
    }
    function attach(entity, ...components) {
      const op = createOp(exports.WorldOpType.Attach, entity, components)
      worldOps.push(op)
    }
    function detach(entity, ...components) {
      const componentTypeIds = components.map(c => c.tid)
      const worldOp = createOp(
        exports.WorldOpType.Detach,
        entity,
        componentTypeIds,
      )
      flagComponents(components, exports.ComponentState.Detaching)
      worldOps.push(worldOp)
    }
    function destroy(entity) {
      const worldOp = createOp(exports.WorldOpType.Destroy, entity)
      const components = storage.getEntityComponents(entity)
      flagComponents(components, exports.ComponentState.Detaching)
      worldOps.push(worldOp)
    }
    function applyOps(opsToApply) {
      for (let i = 0; i < opsToApply.length; i++) {
        const op = opsToApply[i]
        switch (op[0]) {
          case exports.WorldOpType.Detach: {
            const [, entity, componentTypeIds] = op
            const components = componentTypeIds.map(componentTypeId =>
              storage.findComponentByComponentTypeId(entity, componentTypeId),
            )
            for (let j = 0; j < components.length; j++) {
              const component = components[j]
              if (component) {
                flagComponent(component, exports.ComponentState.Detaching)
              }
            }
            break
          }
          case exports.WorldOpType.Destroy: {
            const [, entity] = op
            const components = storage.getEntityComponents(entity)
            flagComponents(components, exports.ComponentState.Detaching)
            break
          }
        }
        applyWorldOp(op)
      }
    }
    function getComponent(entity, componentType) {
      const component = storage.findComponent(entity, componentType)
      if (component === null) {
        throw new Error("Component not found")
      }
      return component
    }
    function tryGetComponent(entity, componentType) {
      return storage.findComponent(entity, componentType)
    }
    function registerComponentType(
      componentType,
      poolSize = componentPoolSize,
    ) {
      const registeredComponentTypeWithTypeId = componentTypes.find(
        ({ type }) => componentType.type === type,
      )
      if (registeredComponentTypeWithTypeId) {
        throw new Error(
          `Tried to register componentType with type id ${componentType.type} more than once.`,
        )
      }
      componentTypes.push(componentType)
      componentPoolsByComponentTypeId.set(
        componentType.type,
        createComponentPool(componentType, poolSize),
      )
    }
    const { getObservedComponent, isComponentChanged, patch } = storage
    const world = {
      addSystem,
      applyOps,
      attach,
      component,
      componentTypes,
      destroy,
      detach,
      getComponent,
      getObservedComponent,
      isComponentChanged,
      ops: worldOpsPrevious,
      patch,
      removeSystem,
      spawn,
      storage,
      tick,
      tryGetComponent,
    }
    return world
  }

  exports.$isDataType = $isDataType
  exports.array = array
  exports.arrayOf = arrayOf
  exports.attached = attached
  exports.boolean = boolean
  exports.changed = changed
  exports.createArchetype = createArchetype
  exports.createComponentBase = createComponentBase
  exports.createComponentFilter = createComponentFilter
  exports.createComponentPool = createComponentPool
  exports.createComponentType = createComponentType
  exports.createDataType = createDataType
  exports.createStorage = createStorage
  exports.createTopic = createTopic
  exports.createWorld = createWorld
  exports.detached = detached
  exports.flagComponent = flagComponent
  exports.flagComponents = flagComponents
  exports.initializeComponentFromSchema = initializeComponentFromSchema
  exports.isComponentOf = isComponentOf
  exports.isDataType = isDataType
  exports.mutableEmpty = mutableEmpty
  exports.mutableRemove = mutableRemove
  exports.mutableRemoveUnordered = mutableRemoveUnordered
  exports.noop = noop
  exports.number = number
  exports.query = query
  exports.resetComponentFromSchema = resetComponentFromSchema
  exports.string = string

  Object.defineProperty(exports, "__esModule", { value: true })
})
