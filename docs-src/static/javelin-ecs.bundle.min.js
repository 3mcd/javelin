(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Javelin = {}));
}(this, (function (exports) { 'use strict';

    function noop(...args) { }

    function mutableRemoveUnordered(arr, element) {
        const length = arr.length;
        const index = arr.indexOf(element);
        if (index === -1) {
            return false;
        }
        const last = arr.pop();
        if (index < length - 1) {
            arr[index] = last;
        }
        return true;
    }
    function mutableRemove(arr, element) {
        const index = arr.indexOf(element);
        if (index === -1) {
            return false;
        }
        arr.splice(index, 1);
        return true;
    }
    function mutableEmpty(arr) {
        while (arr.length > 0)
            arr.pop();
    }
    function arrayOf(len = 0, f = noop) {
        return Array(len)
            .fill(undefined)
            .map((_, i) => f(i));
    }
    function packSparseArray(array) {
        return array.reduce((a, x, i) => {
            a[i] = x;
            return a;
        }, {});
    }
    function unpackSparseArray(packedSparseArray) {
        const sparseArray = [];
        for (const index in packedSparseArray) {
            const i = parseInt(index, 10);
            if (!isNaN(i)) {
                sparseArray[i] = packedSparseArray[index];
            }
        }
        return sparseArray;
    }

    function createArchetypeState(options) {
        const snapshot = "snapshot" in options ? options.snapshot : null;
        const entities = snapshot ? Object.keys(snapshot.indices).map(Number) : [];
        const indices = snapshot ? unpackSparseArray(snapshot.indices) : [];
        const layout = "layout" in options ? options.layout : [...options.snapshot.layout];
        const table = snapshot
            ? snapshot.table.map(column => [...column])
            : layout.map(() => []);
        const layoutInverse = layout.reduce((a, x, i) => {
            a[x] = i;
            return a;
        }, []);
        return { entities, indices, layout, layoutInverse, table };
    }
    /**
     * Create an Archetype.
     *
     * @param layout Array of component types that make up the archetype
     * @param table  Initial component data
     */
    function createArchetype(options) {
        const { layout, layoutInverse, entities, indices, table, } = createArchetypeState(options);
        function insert(entity, components) {
            for (let i = 0; i < components.length; i++) {
                const component = components[i];
                const componentTypeIndex = layoutInverse[component._tid];
                table[componentTypeIndex].push(component);
            }
            indices[entity] = entities.push(entity) - 1;
        }
        function remove(entity) {
            const length = entities.length;
            const index = indices[entity];
            const head = entities.pop();
            delete indices[entity];
            if (index === length - 1) {
                for (const column of table)
                    column.pop();
                return;
            }
            // Move leading entity's components to removed index position
            for (const column of table) {
                column[index] = column.pop();
            }
            // Move leading entity to removed index position
            entities[index] = head;
            // Update previously leading entity's index
            indices[head] = index;
        }
        return {
            layout,
            layoutInverse,
            table,
            indices,
            entities,
            insert,
            remove,
        };
    }

    (function (ComponentState) {
        ComponentState[ComponentState["Orphaned"] = 0] = "Orphaned";
        ComponentState[ComponentState["Attaching"] = 1] = "Attaching";
        ComponentState[ComponentState["Attached"] = 2] = "Attached";
        ComponentState[ComponentState["Detaching"] = 3] = "Detaching";
        ComponentState[ComponentState["Detached"] = 4] = "Detached";
    })(exports.ComponentState || (exports.ComponentState = {}));

    const globals = {
        __WORLDS__: [],
        __CURRENT_WORLD__: -1,
    };

    function isPromise(object) {
        return typeof object === "object" && object !== null && "then" in object;
    }
    function createEffect(factory, options = { throw: false, global: false }) {
        const { global } = options;
        const systemEffectDataByWorldId = [];
        let previousTick;
        let previousWorld;
        let previousSystem;
        let currentWorld;
        let currentSystem;
        let cellCount = -1;
        return function effect(...args) {
            currentWorld = globals.__CURRENT_WORLD__;
            const world = globals.__WORLDS__[currentWorld];
            const currentTick = world.state.currentTick;
            currentSystem = global ? 0 : world.state.currentSystem;
            let currentWorldSystemEffectData = systemEffectDataByWorldId[currentWorld];
            if (systemEffectDataByWorldId[currentWorld] === undefined) {
                currentWorldSystemEffectData = systemEffectDataByWorldId[currentWorld] = [];
            }
            let currentSystemEffect = currentWorldSystemEffectData[currentSystem];
            if (currentSystemEffect === undefined) {
                currentSystemEffect = currentWorldSystemEffectData[currentSystem] = {
                    cells: [],
                    cellCount: -1,
                };
            }
            if (global === true ||
                (previousWorld !== currentWorld && previousWorld !== undefined)) {
                cellCount = 0;
            }
            else if (previousSystem !== undefined &&
                (previousTick !== currentTick || previousSystem !== currentSystem)) {
                let previousSystemEffectData = currentWorldSystemEffectData[previousSystem];
                if (previousSystemEffectData.cellCount !== -1 &&
                    previousSystemEffectData.cellCount !== cellCount) {
                    throw new Error(`Failed to execute effect: encountered too ${previousSystemEffectData.cellCount > cellCount ? "few" : "many"} hooks this tick`);
                }
                previousSystemEffectData.cellCount = cellCount;
                cellCount = 0;
            }
            else {
                cellCount++;
            }
            let cell = currentSystemEffect.cells[cellCount];
            if (!cell) {
                cell = currentSystemEffect.cells[cellCount] = {
                    executor: factory(world),
                    lockGlobal: false,
                    lockAsync: false,
                    lockGlobalTick: -1,
                    state: null,
                };
            }
            if (global) {
                if (cell.lockGlobalTick !== world.state.currentTick) {
                    cell.lockGlobal = false;
                    cell.lockGlobalTick = world.state.currentTick;
                }
                else {
                    cell.lockGlobal = true;
                }
            }
            if (cell.lockGlobal || cell.lockAsync) {
                return cell.state;
            }
            const result = cell.executor(...args);
            if (isPromise(result)) {
                cell.lockAsync = true;
                result
                    .then(result => (cell.state = result))
                    .catch(error => console.error(`Uncaught error in effect: ${error.message}`, error))
                    .then(() => (cell.lockAsync = false));
            }
            else {
                cell.state = result;
            }
            previousTick = currentTick;
            previousWorld = currentWorld;
            previousSystem = currentSystem;
            return cell.state;
        };
    }

    const ref = createEffect(() => {
        let initial = true;
        const state = { value: null };
        return (initialValue) => {
            if (initial) {
                state.value = initialValue;
                initial = false;
            }
            return state;
        };
    });

    const timer = createEffect(() => {
        let state = 0;
        let timer;
        return (duration, invalidate = false) => {
            if (invalidate) {
                state = 0;
                clearTimeout(timer);
            }
            if (state === 0) {
                state = 1;
                timer = setTimeout(() => {
                    state = 2;
                }, duration);
            }
            return state === 2;
        };
    });

    const interval = createEffect(() => (t) => {
        const invalidate = ref(false);
        const done = timer(t, invalidate.value);
        invalidate.value = done;
        return done;
    });

    const request = createEffect(() => {
        let state = { response: null, error: null, done: false };
        let fetching = false;
        let previousUrl;
        let abortController = new window.AbortController();
        return (url, options, invalidate = previousUrl !== undefined && url !== previousUrl) => {
            if (url === null || invalidate) {
                abortController.abort();
                abortController = new AbortController();
            }
            if (url === null) {
                return state;
            }
            if (invalidate) {
                state = { response: state.response, error: null, done: false };
            }
            if (state.done) {
                return state;
            }
            if (!fetching) {
                fetching = true;
                previousUrl = url;
                fetch(url, { ...options, signal: abortController.signal })
                    .then(response => {
                    state = { response, error: null, done: true };
                })
                    .catch(error => {
                    state = { response: state.response, error, done: true };
                })
                    .then(() => {
                    fetching = false;
                });
            }
            return state;
        };
    });

    const json = createEffect(() => {
        let response;
        return (...args) => {
            const previousResponse = ref(null);
            const result = request(...args);
            if (result.response && result.response !== previousResponse.value) {
                result.response.json().then((json) => {
                    response = json;
                });
                previousResponse.value = result.response;
            }
            return { ...result, response: response || null };
        };
    });

    function createComponentFilter(getPredicate) {
        return (componentType) => ({
            componentType,
            componentPredicate: getPredicate(),
        });
    }

    const attached = createComponentFilter(() => ({ _cst: _cst }) => _cst === exports.ComponentState.Attaching);

    const changed = createComponentFilter(() => (c, { isComponentChanged }) => isComponentChanged(c));

    const detached = createComponentFilter(() => ({ _cst: _cst }) => _cst === exports.ComponentState.Detached);

    function createStackPool(type, reset, size) {
        const heap = [];
        const allocate = () => {
            for (let i = 0; i < size; i++) {
                heap.push(type(pool));
            }
        };
        const retain = () => {
            if (!heap.length) {
                allocate();
            }
            return heap.pop();
        };
        const release = (obj) => {
            heap.push(reset(obj));
        };
        const pool = {
            allocate,
            retain,
            release,
        };
        return pool;
    }

    const $isDataType = Symbol("is_data_type");

    function createDataType(config) {
        return { ...config, [$isDataType]: true };
    }
    function isDataType(obj) {
        return typeof obj === "object" && obj !== null && obj[$isDataType];
    }
    function initializeComponentFromSchema(component, schema) {
        for (const prop in schema) {
            const value = schema[prop];
            if (isDataType(value)) {
                // DataType
                component[prop] = value.create(undefined);
            }
            else if ("type" in value && isDataType(value.type)) {
                // DataType with defaultValue
                const { type, defaultValue } = value;
                component[prop] = type.create(defaultValue);
            }
            else {
                // Schema
                initializeComponentFromSchema(component, value);
            }
        }
        return component;
    }
    function resetComponentFromSchema(component, schema) {
        component._cst = exports.ComponentState.Orphaned;
        for (const prop in schema) {
            const value = schema[prop];
            if (isDataType(value)) {
                // DataType
                value.reset(component, prop, undefined);
            }
            else if ("type" in value && isDataType(value.type)) {
                // DataType with defaultValue
                const { type, defaultValue } = value;
                type.reset(component, prop, defaultValue);
            }
            else {
                // Schema
                resetComponentFromSchema(component, value);
            }
        }
        return component;
    }
    function serializeSchema(schema) {
        const out = {};
        for (const prop in schema) {
            const value = schema[prop];
            if (isDataType(value)) {
                out[prop] = value.name;
            }
            else if ("type" in value && isDataType(value.type)) {
                out[prop] = value.type.name;
            }
            else {
                out[prop] = serializeSchema(value);
            }
        }
        return out;
    }
    function schemaEqualsSerializedSchema(schema, serializedSchema) {
        if (Object.keys(schema).length !== Object.keys(serializedSchema).length) {
            return false;
        }
        for (const prop in schema) {
            const value = schema[prop];
            if (isDataType(value)) {
                if (serializedSchema[prop] !== value.name) {
                    return false;
                }
            }
            else if ("type" in value && isDataType(value.type)) {
                if (serializedSchema[prop] !== value.type.name) {
                    return false;
                }
            }
            else {
                const result = schemaEqualsSerializedSchema(value, serializedSchema[prop]);
                if (!result) {
                    return false;
                }
            }
        }
        return true;
    }

    function createComponentType(componentType) {
        return componentType;
    }
    function createComponentBase(componentType) {
        return Object.defineProperties({}, {
            _tid: { value: componentType.type, writable: false, enumerable: true },
            _cst: {
                value: exports.ComponentState.Orphaned,
                writable: true,
                enumerable: false,
            },
        });
    }
    function serializeComponentType(componentType) {
        return {
            name: componentType.name,
            type: componentType.type,
            schema: serializeSchema(componentType.schema),
        };
    }
    function createComponentPool(componentType, poolSize) {
        const componentPool = createStackPool(() => initializeComponentFromSchema(createComponentBase(componentType), componentType.schema), c => resetComponentFromSchema(c, componentType.schema), poolSize);
        return componentPool;
    }
    function isComponentOf(component, componentTypeId) {
        return component._tid === componentTypeId.type;
    }
    function flagComponent(component, state) {
        component._cst = state;
    }
    function flagComponents(components, state) {
        for (let i = 0; i < components.length; i++) {
            flagComponent(components[i], state);
        }
    }

    class QueryIterable {
        constructor(selector, onDone) {
            this.queryLength = -1;
            this.queryLayout = [];
            this.componentFilterPredicates = [];
            this.queryResult = [-1];
            this.readIndices = [];
            this.onDone = null;
            this.onDoneBound = () => this.onDone(this);
            this.entityIndex = -1;
            this.archetypeIndex = -1;
            this.currentArchetype = null;
            this.next = () => {
                if (this.currentArchetype === null) {
                    this.visitNextArchetype();
                }
                else {
                    this.visitNextEntity();
                }
                return this.iteratorResult;
            };
            this.componentFilterPredicates = selector.map(s => "componentPredicate" in s ? s.componentPredicate : null);
            this.queryLayout = selector.map(s => "componentType" in s ? s.componentType.type : s.type);
            this.queryLength = selector.length;
            this.iterable = {
                next: this.next,
            };
            this.iteratorResult = {
                value: this.queryResult,
                done: false,
            };
            this.onDone = onDone;
        }
        reset() {
            this.entityIndex = -1;
            this.archetypeIndex = -1;
            this.currentArchetype = null;
            this.iteratorResult.done = false;
        }
        visitNextArchetype() {
            const { queryLayout, queryLength, readIndices } = this;
            outer: while ((this.currentArchetype = globals.__WORLDS__[globals.__CURRENT_WORLD__].storage.archetypes[++this.archetypeIndex])) {
                const { layoutInverse } = this.currentArchetype;
                for (let i = 0; i < queryLength; i++) {
                    const index = layoutInverse[queryLayout[i]];
                    if (index === undefined) {
                        continue outer;
                    }
                    readIndices[i] = index;
                }
                this.entityIndex = -1;
                this.visitNextEntity();
                return;
            }
            this.iteratorResult.done = true;
            setTimeout(this.onDoneBound);
        }
        visitNextEntity() {
            var _a, _b;
            const { currentArchetype, readIndices, componentFilterPredicates } = this;
            const { table, entities } = currentArchetype;
            const length = entities.length;
            outer: while (++this.entityIndex < length) {
                this.queryResult[0] = entities[this.entityIndex];
                for (let i = 0; i < this.queryLength; i++) {
                    const component = table[readIndices[i]][this.entityIndex];
                    if ((_b = (_a = componentFilterPredicates[i]) === null || _a === void 0 ? void 0 : _a.call(componentFilterPredicates, component, globals.__WORLDS__[globals.__CURRENT_WORLD__])) !== null && _b !== void 0 ? _b : component._cst === 2) {
                        this.queryResult[i + 1] = component;
                    }
                    else {
                        continue outer;
                    }
                }
                return;
            }
            this.visitNextArchetype();
        }
    }
    /**
     * Create a Query with a given set of component types.
     *
     * @param selector Component makeup of entities
     */
    function query(...selector) {
        const pool = createStackPool(pool => new QueryIterable(selector, pool.release), q => {
            q.reset();
            return q;
        }, 100);
        return {
            [Symbol.iterator]() {
                return pool.retain().iterable;
            },
        };
    }

    const array = (type) => createDataType({
        name: "array",
        create(value = []) {
            return value;
        },
        reset(c, key, defaultValue) {
            if (typeof defaultValue !== "undefined") {
                c[key] = defaultValue.slice();
            }
            else {
                mutableEmpty(c[key]);
            }
        },
    });
    const number = createDataType({
        name: "number",
        create(value = 0) {
            return value;
        },
        reset(c, key, value = 0) {
            c[key] = value;
        },
    });
    const boolean = createDataType({
        name: "boolean",
        create(value = false) {
            return value;
        },
        reset(c, key, value = false) {
            c[key] = value;
        },
    });
    const string = createDataType({
        name: "string",
        create(value = "") {
            return value;
        },
        reset(c, key, value = "") {
            c[key] = value;
        },
    });

    const rMethod = /^\d+\(\)$/;
    const rInteger = /\d+/;
    let splitPathCache = {};
    function splitPath(path) {
        let splitPath = splitPathCache[path];
        if (!splitPath) {
            splitPath = path.split(".");
            for (let i = 0; i < splitPath.length; i++) {
                const pathComponent = splitPath[i];
                if (rInteger.test(pathComponent)) {
                    splitPath[i] = Number(pathComponent);
                }
            }
            splitPathCache[path] = splitPath;
        }
        return splitPath;
    }
    function applyMutation(root, path, value) {
        var _a;
        const arrPath = splitPath(path);
        const key = arrPath[arrPath.length - 1];
        let target = root;
        for (let i = 0; i < arrPath.length - 1; i++) {
            // @ts-ignore
            target = target[arrPath[i]];
        }
        const methodMatches = typeof key === "string" && key.match(rMethod);
        const methodType = methodMatches ? Number(methodMatches[0]) : null;
        if (typeof methodType === "number") {
            // @ts-ignore
            (_a = mutArrayMethodsByType
                .get(methodType)) === null || _a === void 0 ? void 0 : _a.apply(arrPath[arrPath.length - 2], value);
        }
        // @ts-ignore
        target[key] = value;
    }
    const isValidProxyTarget = (obj) => (typeof obj === "object" && obj !== null) || typeof obj === "function";
    var MutArrayMethodType;
    (function (MutArrayMethodType) {
        MutArrayMethodType[MutArrayMethodType["Push"] = 0] = "Push";
        MutArrayMethodType[MutArrayMethodType["Pop"] = 1] = "Pop";
        MutArrayMethodType[MutArrayMethodType["Shift"] = 2] = "Shift";
        MutArrayMethodType[MutArrayMethodType["Unshift"] = 3] = "Unshift";
        MutArrayMethodType[MutArrayMethodType["Splice"] = 4] = "Splice";
    })(MutArrayMethodType || (MutArrayMethodType = {}));
    const MUT_ARRAY_METHODS = new Map([
        [Array.prototype.push, MutArrayMethodType.Push],
        [Array.prototype.pop, MutArrayMethodType.Pop],
        [Array.prototype.shift, MutArrayMethodType.Shift],
        [Array.prototype.unshift, MutArrayMethodType.Unshift],
        [Array.prototype.splice, MutArrayMethodType.Splice],
    ]);
    const mutArrayMethodsByType = new Map([
        [MutArrayMethodType.Push, Array.prototype.push],
        [MutArrayMethodType.Pop, Array.prototype.pop],
        [MutArrayMethodType.Shift, Array.prototype.shift],
        [MutArrayMethodType.Unshift, Array.prototype.unshift],
        [MutArrayMethodType.Splice, Array.prototype.splice],
    ]);
    const ROOT_PATH = "";
    const createMutationCache = ({ onChange, }) => {
        const targetRoots = new WeakMap();
        const targetPaths = new WeakMap();
        const targetProxies = new WeakMap();
        const proxyTargetLookup = new WeakMap();
        const locked = new WeakSet();
        function getPath(target, key) {
            const basePath = targetPaths.get(target);
            if (basePath === ROOT_PATH) {
                return key.toString();
            }
            return `${basePath}.${key}`;
        }
        function getProxy(target, root = target, path = ROOT_PATH) {
            let proxy = targetProxies.get(target);
            if (proxy === undefined) {
                proxy = new Proxy(target, handler);
                targetProxies.set(target, proxy);
                proxyTargetLookup.set(proxy, target);
                targetRoots.set(target, root);
                targetPaths.set(target, path);
            }
            return proxy;
        }
        const handler = {
            get(target, propertyKey, receiver) {
                const value = Reflect.get(target, propertyKey, receiver);
                if (typeof propertyKey !== "symbol" && isValidProxyTarget(value)) {
                    return getProxy(value, targetRoots.get(target), getPath(target, propertyKey));
                }
                return value;
            },
            set(target, propertyKey, value, receiver) {
                const previous = target[propertyKey];
                target[propertyKey] = value;
                if (previous !== value &&
                    !locked.has(target) &&
                    typeof propertyKey !== "symbol") {
                    onChange(targetRoots.get(target), target, getPath(target, propertyKey), value);
                }
                return true;
            },
            apply(target, thisArgument, argumentsList) {
                const isArray = Array.isArray(thisArgument);
                const targetProxy = proxyTargetLookup.get(thisArgument);
                let mutArrayMethodType = MUT_ARRAY_METHODS.get(target);
                let hasMutArrayMethodType = isArray && typeof mutArrayMethodType === "number";
                if (hasMutArrayMethodType) {
                    locked.add(targetProxy);
                }
                const result = Reflect.apply(target, thisArgument, argumentsList);
                if (hasMutArrayMethodType) {
                    onChange(targetRoots.get(targetProxy), thisArgument, getPath(targetProxy, `${mutArrayMethodType}()`), argumentsList);
                    locked.delete(thisArgument);
                }
                return result;
            },
        };
        function revoke(target) {
            const proxy = targetProxies.get(target);
            targetProxies.delete(target);
            proxyTargetLookup.delete(proxy);
        }
        function proxy(target) {
            return getProxy(target);
        }
        return {
            proxy,
            revoke,
        };
    };

    function createStorage(options = {}) {
        const mutationCache = createMutationCache({
            onChange(component, target, path, value, mutArrayMethodType) {
                let changes = mutations.get(component);
                if (!changes) {
                    changes = [];
                    mutations.set(component, changes);
                }
                if (mutArrayMethodType) {
                    changes.push(path, value, mutArrayMethodType);
                }
                else {
                    changes.push(path, value);
                }
            },
        });
        const mutations = new Map();
        const archetypes = options.snapshot
            ? options.snapshot.archetypes.map(snapshot => createArchetype({ snapshot }))
            : [];
        // Array where the index corresponds to an entity and the value corresponds
        // to the index of the entity's archetype within the `archetypes` array. When
        // mutating or reading components, we always assume the location is valid
        // since it is kept in sync with the entity's archetype via the `create`,
        // `insert`, and `remove` methods.
        const archetypeIndicesByEntity = [];
        /**
         * Locate an archetype for a collection of components.
         *
         * @param components Components that archetype would contain
         */
        function findArchetype(components) {
            const len = components.length;
            for (let i = 0; i < archetypes.length; i++) {
                const archetype = archetypes[i];
                const { layout } = archetype;
                // Verify archetype has same number of components as predicate.
                if (layout.length !== len) {
                    continue;
                }
                let match = true;
                for (let j = 0; j < len; j++) {
                    // Affirm that archetype contains each component of predicate.
                    if (layout.indexOf(components[j]._tid) === -1) {
                        match = false;
                        break;
                    }
                }
                if (match) {
                    return archetype;
                }
            }
            return null;
        }
        /**
         * Locate or create an archetype for a collection of components.
         *
         * @param components Components that archetype would contain
         */
        function findOrCreateArchetype(components) {
            let archetype = findArchetype(components);
            if (!archetype) {
                archetype = createArchetype({ layout: components.map(c => c._tid) });
                archetypes.push(archetype);
            }
            return archetype;
        }
        function create(entity, components) {
            const archetype = findOrCreateArchetype(components);
            archetype.insert(entity, components);
            archetypeIndicesByEntity[entity] = archetypes.indexOf(archetype);
            return entity;
        }
        function getEntityArchetype(entity) {
            const location = archetypeIndicesByEntity[entity];
            if (location === undefined) {
                throw new Error(`Failed to locate entity. Entity does not exist.`);
            }
            if (location === null) {
                throw new Error(`Failed to locate entity. Entity has been removed.`);
            }
            return archetypes[location];
        }
        function relocate(source, entity, components) {
            source.remove(entity);
            if (components.length === 0) {
                return;
            }
            const destination = findOrCreateArchetype(components);
            destination.insert(entity, components);
            archetypeIndicesByEntity[entity] = archetypes.indexOf(destination);
        }
        function insert(entity, components) {
            const source = getEntityArchetype(entity);
            const entityIndex = source.indices[entity];
            let destinationComponents = components.slice();
            for (let i = 0; i < source.layout.length; i++) {
                const componentTypeId = source.layout[i];
                if (components.find(c => c._tid === componentTypeId)) {
                    throw new Error(`Cannot attach component with type ${componentTypeId} — entity already has component of type.`);
                }
                // UNSAFE: `!` is used because entity location is non-null.
                destinationComponents.push(source.table[i][entityIndex]);
            }
            relocate(source, entity, destinationComponents);
        }
        function remove(entity, components) {
            const typesToRemove = components.map(component => component._tid);
            removeByTypeIds(entity, typesToRemove);
        }
        function removeByTypeIds(entity, componentTypeIds) {
            const source = getEntityArchetype(entity);
            const entityIndex = source.indices[entity];
            let destinationComponents = [];
            for (let i = 0; i < source.layout.length; i++) {
                const type = source.layout[i];
                const component = source.table[i][entityIndex];
                if (!componentTypeIds.includes(type)) {
                    destinationComponents.push(component);
                }
                else {
                    mutationCache.revoke(component);
                    mutations.delete(component);
                }
            }
            relocate(source, entity, destinationComponents);
        }
        function destroy(entity) {
            remove(entity, getComponentsOfEntity(entity));
            archetypeIndicesByEntity[entity] = null;
        }
        function patch(entity, componentTypeId, path, value) {
            const archetype = getEntityArchetype(entity);
            const entityIndex = archetype.indices[entity];
            const column = archetype.layoutInverse[componentTypeId];
            if (column === undefined) {
                return;
            }
            const target = getObservedComponent(archetype.table[column][entityIndex]);
            applyMutation(target, path, value);
        }
        const tmpComponentsToInsert = [];
        function upsert(entity, components) {
            const archetype = getEntityArchetype(entity);
            const entityIndex = archetype.indices[entity];
            mutableEmpty(tmpComponentsToInsert);
            for (let i = 0; i < components.length; i++) {
                const component = components[i];
                const column = archetype.layoutInverse[component._tid];
                if (column === undefined) {
                    // Entity component makeup does not match patch component, insert the new
                    // component.
                    tmpComponentsToInsert.push(component);
                }
                else {
                    const target = getObservedComponent(archetype.table[column][entityIndex]);
                    // Apply patch to component.
                    Object.assign(target, component);
                }
            }
            if (tmpComponentsToInsert.length > 0) {
                insert(entity, tmpComponentsToInsert);
            }
        }
        function findComponent(entity, componentType) {
            return findComponentByComponentTypeId(entity, componentType.type);
        }
        function findComponentByComponentTypeId(entity, componentTypeId) {
            const archetype = getEntityArchetype(entity);
            const column = archetype.layoutInverse[componentTypeId];
            if (column === undefined) {
                return null;
            }
            const entityIndex = archetype.indices[entity];
            // UNSAFE: `!` is used because entity location is non-null.
            return archetype.table[column][entityIndex];
        }
        function getComponentsOfEntity(entity) {
            const archetype = getEntityArchetype(entity);
            const entityIndex = archetype.indices[entity];
            const result = [];
            for (let i = 0; i < archetype.table.length; i++) {
                result.push(archetype.table[i][entityIndex]);
            }
            return result;
        }
        function clearMutations() {
            mutations.forEach(mutableEmpty);
        }
        function getMutationsOfComponent(component) {
            const changeSet = mutations.get(component);
            if (!changeSet) {
                throw new Error("ChangeSet does not exist for component.");
            }
            return changeSet;
        }
        function getObservedComponent(component) {
            return mutationCache.proxy(component);
        }
        function isComponentChanged(component) {
            const changeSet = mutations.get(component);
            return changeSet ? changeSet.length > 0 : false;
        }
        function clear() {
            mutations.clear();
            mutableEmpty(archetypes);
            mutableEmpty(archetypeIndicesByEntity);
        }
        function snapshot() {
            return {
                archetypes: archetypes.map(archetype => ({
                    layout: archetype.layout.slice(),
                    table: archetype.table.map(column => column.map(component => ({ ...component }))),
                    indices: packSparseArray(archetype.indices),
                })),
            };
        }
        return {
            archetypes,
            clear,
            clearMutations,
            create,
            destroy,
            findComponent,
            findComponentByComponentTypeId,
            getComponentMutations: getMutationsOfComponent,
            getEntityComponents: getComponentsOfEntity,
            getObservedComponent,
            insert,
            isComponentChanged,
            patch,
            remove,
            removeByTypeIds,
            snapshot,
            upsert,
        };
    }

    /**
     * The utility method used to create a topic, consumes a type parameter
     * and a name and returns an object that conforms to the topic type
     */
    const createTopic = () => {
        const staged = [];
        const ready = [];
        const push = (event) => staged.push(event);
        const pushImmediate = (event) => ready.push(event);
        const flush = () => {
            mutableEmpty(ready);
            const len = staged.length;
            for (let i = len - 1; i >= 0; i--) {
                ready[i] = staged.pop();
            }
        };
        return {
            *[Symbol.iterator]() {
                for (let i = 0; i < ready.length; i++) {
                    yield ready[i];
                }
            },
            push,
            pushImmediate,
            flush,
        };
    };

    (function (WorldOpType) {
        WorldOpType[WorldOpType["Spawn"] = 0] = "Spawn";
        WorldOpType[WorldOpType["Attach"] = 1] = "Attach";
        WorldOpType[WorldOpType["Detach"] = 2] = "Detach";
        WorldOpType[WorldOpType["Mutate"] = 3] = "Mutate";
        WorldOpType[WorldOpType["Destroy"] = 4] = "Destroy";
    })(exports.WorldOpType || (exports.WorldOpType = {}));

    function getInitialWorldState() {
        return {
            currentTickData: null,
            currentTick: 0,
            currentSystem: 0,
        };
    }
    function createWorld(options = {}) {
        var _a, _b;
        const { componentPoolSize = 1000 } = options;
        const worldOps = [];
        const worldOpsPrevious = [];
        const worldOpPool = createStackPool(() => [], op => {
            mutableEmpty(op);
            return op;
        }, 1000);
        const componentTypes = [];
        const componentPoolsByComponentTypeId = new Map();
        const storage = createStorage({ snapshot: (_a = options.snapshot) === null || _a === void 0 ? void 0 : _a.storage });
        const destroyed = new Set();
        const detached = new Map();
        const attaching = [];
        const systems = [];
        const systemIdBySystemIndex = [];
        let state = getInitialWorldState();
        let entityCounter = 0;
        let systemCounter = 0;
        (_b = options.systems) === null || _b === void 0 ? void 0 : _b.forEach(addSystem);
        function applySpawnOp(op) {
            const [, entity, components] = op;
            flagComponents(components, exports.ComponentState.Attaching);
            attaching.push(components);
            storage.create(entity, components);
        }
        function applyAttachOp(op) {
            const [, entity, components] = op;
            flagComponents(components, exports.ComponentState.Attaching);
            attaching.push(components);
            storage.insert(entity, components);
        }
        function applyDetachOp(op) {
            const [, entity, componentTypeIds] = op;
            for (let i = 0; i < componentTypeIds.length; i++) {
                const component = storage.findComponentByComponentTypeId(entity, componentTypeIds[i]);
                flagComponent(component, exports.ComponentState.Detached);
            }
            detached.set(entity, componentTypeIds);
        }
        function applyDestroyOp(op) {
            const [, entity] = op;
            const components = storage.getEntityComponents(entity);
            flagComponents(components, exports.ComponentState.Detached);
            destroyed.add(entity);
        }
        function applyWorldOp(worldOp, record = true) {
            if (record === true) {
                worldOpsPrevious.push(worldOp);
            }
            switch (worldOp[0]) {
                case exports.WorldOpType.Spawn:
                    return applySpawnOp(worldOp);
                case exports.WorldOpType.Attach:
                    return applyAttachOp(worldOp);
                case exports.WorldOpType.Detach:
                    return applyDetachOp(worldOp);
                case exports.WorldOpType.Destroy:
                    return applyDestroyOp(worldOp);
            }
        }
        function maybeReleaseComponent(component) {
            const pool = componentPoolsByComponentTypeId.get(component._tid);
            if (pool) {
                pool.release(component);
            }
        }
        function finalDestroy(entity) {
            storage.getEntityComponents(entity).forEach(maybeReleaseComponent);
            storage.destroy(entity);
        }
        function finalDetach(componentTypeIds, entity) {
            for (let i = 0; i < componentTypeIds.length; i++) {
                const component = storage.findComponentByComponentTypeId(entity, componentTypeIds[i]);
                maybeReleaseComponent(component);
            }
            storage.removeByTypeIds(entity, componentTypeIds);
        }
        function maintain() {
            // Clear change cache
            storage.clearMutations();
            // Clear world op history
            while (worldOpsPrevious.length > 0) {
                worldOpPool.release(worldOpsPrevious.pop());
            }
            while (attaching.length > 0) {
                flagComponents(attaching.pop(), exports.ComponentState.Attached);
            }
            detached.forEach(finalDetach);
            detached.clear();
            destroyed.forEach(finalDestroy);
            destroyed.clear();
            while (worldOps.length > 0) {
                applyWorldOp(worldOps.pop());
            }
        }
        function tick(data) {
            globals.__CURRENT_WORLD__ = id;
            state.currentTickData = data;
            if (state.currentTick === 0) {
                maintain();
            }
            maintain();
            // Execute systems
            for (let i = 0; i < systems.length; i++) {
                world.state.currentSystem = systemIdBySystemIndex[i];
                systems[i](world);
            }
            state.currentTick++;
        }
        function addSystem(system) {
            const index = systems.push(system) - 1;
            systemIdBySystemIndex[index] = systemCounter++;
        }
        function removeSystem(system) {
            const index = systems.indexOf(system);
            if (index > -1) {
                systems.splice(index, 1);
                delete systemIdBySystemIndex[index];
            }
        }
        function component(componentType, ...args) {
            const componentTypeHasBeenRegistered = componentTypes.includes(componentType);
            if (!componentTypeHasBeenRegistered) {
                registerComponentType(componentType);
            }
            const pool = componentPoolsByComponentTypeId.get(componentType.type);
            const component = pool.retain();
            if (componentType.initialize) {
                componentType.initialize(component, ...args);
            }
            return component;
        }
        function createOp(...args) {
            const worldOp = worldOpPool.retain();
            for (let i = 0; i < args.length; i++) {
                worldOp[i] = args[i];
            }
            return worldOp;
        }
        function spawn(...components) {
            const entity = entityCounter++;
            const worldOp = createOp(exports.WorldOpType.Spawn, entity, components);
            worldOps.push(worldOp);
            return entity;
        }
        function attach(entity, ...components) {
            const op = createOp(exports.WorldOpType.Attach, entity, components);
            worldOps.push(op);
        }
        function detach(entity, ...components) {
            const componentTypeIds = components.map(c => c._tid);
            const worldOp = createOp(exports.WorldOpType.Detach, entity, componentTypeIds);
            flagComponents(components, exports.ComponentState.Detaching);
            worldOps.push(worldOp);
        }
        function destroy(entity) {
            const worldOp = createOp(exports.WorldOpType.Destroy, entity);
            const components = storage.getEntityComponents(entity);
            flagComponents(components, exports.ComponentState.Detaching);
            worldOps.push(worldOp);
        }
        function applyOps(opsToApply) {
            for (let i = 0; i < opsToApply.length; i++) {
                const op = opsToApply[i];
                switch (op[0]) {
                    case exports.WorldOpType.Detach: {
                        const [, entity, componentTypeIds] = op;
                        const components = componentTypeIds.map(componentTypeId => storage.findComponentByComponentTypeId(entity, componentTypeId));
                        for (let j = 0; j < components.length; j++) {
                            const component = components[j];
                            if (component) {
                                flagComponent(component, exports.ComponentState.Detaching);
                            }
                        }
                        break;
                    }
                    case exports.WorldOpType.Destroy: {
                        const [, entity] = op;
                        const components = storage.getEntityComponents(entity);
                        flagComponents(components, exports.ComponentState.Detaching);
                        break;
                    }
                }
                applyWorldOp(op, false);
            }
        }
        function getComponent(entity, componentType) {
            const component = storage.findComponent(entity, componentType);
            if (component === null) {
                throw new Error("Component not found");
            }
            return component;
        }
        function tryGetComponent(entity, componentType) {
            return storage.findComponent(entity, componentType);
        }
        function registerComponentType(componentType, poolSize = componentPoolSize) {
            const registeredComponentTypeWithTypeId = componentTypes.find(({ type }) => componentType.type === type);
            if (registeredComponentTypeWithTypeId) {
                throw new Error(`Failed to register component type: a componentType with same id is already registered`);
            }
            if (options.snapshot) {
                const snapshotComponentTypeWithTypeId = options.snapshot.componentTypes.find(s => s.type === componentType.type);
                if (snapshotComponentTypeWithTypeId &&
                    !schemaEqualsSerializedSchema(componentType.schema, snapshotComponentTypeWithTypeId.schema)) {
                    throw new Error(`Failed to register component type: component type schema does not match world snapshot`);
                }
            }
            componentTypes.push(componentType);
            componentPoolsByComponentTypeId.set(componentType.type, createComponentPool(componentType, poolSize));
        }
        function reset() {
            mutableEmpty(worldOps);
            mutableEmpty(worldOpsPrevious);
            mutableEmpty(componentTypes);
            mutableEmpty(systems);
            mutableEmpty(attaching);
            componentPoolsByComponentTypeId.clear();
            destroyed.clear();
            detached.clear();
            state = getInitialWorldState();
            entityCounter = 0;
            while (worldOps.length > 0) {
                worldOpPool.release(worldOps.pop());
            }
            while (worldOpsPrevious.length > 0) {
                worldOpPool.release(worldOpsPrevious.pop());
            }
            // Prior to clearing storage, release each component back to its pool.
            for (let i = 0; i < storage.archetypes.length; i++) {
                const archetype = storage.archetypes[i];
                for (let j = 0; j < archetype.layout.length; j++) {
                    const column = archetype.table[j];
                    const componentPool = componentPoolsByComponentTypeId.get(archetype.layout[j]);
                    for (let k = 0; k < column.length; k++) {
                        const component = column[k];
                        componentPool === null || componentPool === void 0 ? void 0 : componentPool.release(component);
                    }
                }
            }
            storage.clear();
        }
        function snapshot() {
            return {
                componentTypes: componentTypes.map(serializeComponentType),
                storage: storage.snapshot(),
            };
        }
        const { getObservedComponent, isComponentChanged, patch } = storage;
        const world = {
            addSystem,
            applyOps,
            attach,
            component,
            componentTypes,
            destroy,
            detach,
            getComponent,
            getObservedComponent,
            id: -1,
            isComponentChanged,
            ops: worldOpsPrevious,
            patch,
            removeSystem,
            reset,
            snapshot,
            spawn,
            state,
            storage,
            tick,
            tryGetComponent,
        };
        let id = (world.id = globals.__WORLDS__.push(world) - 1);
        return world;
    }

    exports.$isDataType = $isDataType;
    exports.array = array;
    exports.arrayOf = arrayOf;
    exports.attached = attached;
    exports.boolean = boolean;
    exports.changed = changed;
    exports.createArchetype = createArchetype;
    exports.createComponentBase = createComponentBase;
    exports.createComponentFilter = createComponentFilter;
    exports.createComponentPool = createComponentPool;
    exports.createComponentType = createComponentType;
    exports.createDataType = createDataType;
    exports.createEffect = createEffect;
    exports.createStorage = createStorage;
    exports.createTopic = createTopic;
    exports.createWorld = createWorld;
    exports.detached = detached;
    exports.flagComponent = flagComponent;
    exports.flagComponents = flagComponents;
    exports.initializeComponentFromSchema = initializeComponentFromSchema;
    exports.interval = interval;
    exports.isComponentOf = isComponentOf;
    exports.isDataType = isDataType;
    exports.json = json;
    exports.mutableEmpty = mutableEmpty;
    exports.mutableRemove = mutableRemove;
    exports.mutableRemoveUnordered = mutableRemoveUnordered;
    exports.noop = noop;
    exports.number = number;
    exports.packSparseArray = packSparseArray;
    exports.query = query;
    exports.ref = ref;
    exports.request = request;
    exports.resetComponentFromSchema = resetComponentFromSchema;
    exports.schemaEqualsSerializedSchema = schemaEqualsSerializedSchema;
    exports.serializeComponentType = serializeComponentType;
    exports.serializeSchema = serializeSchema;
    exports.string = string;
    exports.timer = timer;
    exports.unpackSparseArray = unpackSparseArray;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
