<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />

    <!-- Enable responsiveness on mobile devices-->
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1"
    />

    <title>Javelin Docs</title>

    <script src="/javelin-ecs.bundle.min.js" type="text/javascript"></script>

    <!-- CSS -->

    <link rel="preconnect" href="https://fonts.gstatic.com" />
    <link
      href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@0,400;0,700;1,400&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="https://javelin.games/book.css" />
  </head>

  <body>
    <header>
      <section>
        <nav>
          <a class="fat" href="/introduction"><h1>Javelin</h1></a>
          <a
            class="version"
            href="https:&#x2F;&#x2F;github.com&#x2F;3mcd&#x2F;javelin/releases/tag/v0.21.0"
            >v0.21.0</a
          >
        </nav>
        <nav>
          <a class="fat disabled" href="#">API Docs</a>
          <a
            class="fat"
            href="https:&#x2F;&#x2F;github.com&#x2F;3mcd&#x2F;javelin"
            >GitHub</a
          >
        </nav>
      </section>
    </header>
    <main>
      <section>
        <div class="menu">
          <nav role="navigation">
            <ul>
              <li>
                <a
                  href="https:&#x2F;&#x2F;javelin.games&#x2F;introduction&#x2F;"
                >
                  <span>1. </span>
                  <strong>Introduction</strong>
                </a>
              </li>

              <li>
                <a href="https:&#x2F;&#x2F;javelin.games&#x2F;ecs&#x2F;">
                  <span>2. </span>
                  <strong>ECS</strong>
                </a>

                <ul>
                  <li>
                    <a
                      href="https:&#x2F;&#x2F;javelin.games&#x2F;ecs&#x2F;world&#x2F;"
                    >
                      World
                    </a>
                  </li>

                  <li>
                    <a
                      href="https:&#x2F;&#x2F;javelin.games&#x2F;ecs&#x2F;components&#x2F;"
                    >
                      Components
                    </a>
                  </li>

                  <li>
                    <a
                      href="https:&#x2F;&#x2F;javelin.games&#x2F;ecs&#x2F;entities&#x2F;"
                    >
                      Entities
                    </a>
                  </li>

                  <li class="active">
                    <a
                      href="https:&#x2F;&#x2F;javelin.games&#x2F;ecs&#x2F;systems&#x2F;"
                    >
                      Systems
                    </a>
                  </li>

                  <li>
                    <a
                      href="https:&#x2F;&#x2F;javelin.games&#x2F;ecs&#x2F;effects&#x2F;"
                    >
                      Effects
                    </a>
                  </li>

                  <li>
                    <a
                      href="https:&#x2F;&#x2F;javelin.games&#x2F;ecs&#x2F;events&#x2F;"
                    >
                      Events
                    </a>
                  </li>

                  <li>
                    <a
                      href="https:&#x2F;&#x2F;javelin.games&#x2F;ecs&#x2F;topics&#x2F;"
                    >
                      Topics
                    </a>
                  </li>

                  <li>
                    <a
                      href="https:&#x2F;&#x2F;javelin.games&#x2F;ecs&#x2F;change-detection&#x2F;"
                    >
                      Change Detection
                    </a>
                  </li>

                  <li>
                    <a
                      href="https:&#x2F;&#x2F;javelin.games&#x2F;ecs&#x2F;performance&#x2F;"
                    >
                      Performance
                    </a>
                  </li>
                </ul>
              </li>

              <li>
                <a href="https:&#x2F;&#x2F;javelin.games&#x2F;networking&#x2F;">
                  <span>3. </span>
                  <strong>Networking</strong>
                </a>
              </li>

              <li>
                <a href="https:&#x2F;&#x2F;javelin.games&#x2F;resources&#x2F;">
                  <span>4. </span>
                  <strong>Resources</strong>
                </a>
              </li>
            </ul>
          </nav>
        </div>

        <div class="page">
          <div class="page__content">
            <div class="search-container">
              <input id="search" type="search" placeholder="Search.." />
              <div class="search-results">
                <div class="search-results__header"></div>
                <ul class="search-results__items"></ul>
              </div>
            </div>

            <div class="book-content">
              <h1>Systems</h1>
              <p>
                A <strong>system</strong> is simply a function executed during
                each world tick. All game logic should live within systems.
              </p>
              <h2 id="game-logic">
                Game Logic<a
                  class="zola-anchor"
                  href="#game-logic"
                  aria-label="Anchor link for: game-logic"
                  >#</a
                >
              </h2>
              <p>
                Each system should implement some subset of your game's logic.
                Ideally a system manages a small number of concerns. There is
                minimal performance overhead to having multiple small systems
                versus monolithic ones, and smaller systems are easier to read,
                test, and maintain.
              </p>
              <p>
                Below is an example set of systems that could be found in a
                top-down ARPG.
              </p>
              <table>
                <thead>
                  <tr>
                    <th>System</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><code>sysAiEnemy</code></td>
                    <td>Enemy AI logic</td>
                  </tr>
                  <tr>
                    <td><code>sysAiCompanion</code></td>
                    <td>Companion AI logic</td>
                  </tr>
                  <tr>
                    <td><code>sysInput</code></td>
                    <td>Sample mouse/keyboard input</td>
                  </tr>
                  <tr>
                    <td><code>sysCombat</code></td>
                    <td>Transform controller input to combat actions</td>
                  </tr>
                  <tr>
                    <td><code>sysMovement</code></td>
                    <td>Transform controller input to movement actions</td>
                  </tr>
                  <tr>
                    <td><code>sysPhysics</code></td>
                    <td>Apply forces and step physics simulation</td>
                  </tr>
                  <tr>
                    <td><code>sysPickups</code></td>
                    <td>
                      Detect collisions with items and update player inventory
                    </td>
                  </tr>
                  <tr>
                    <td><code>sysRender</code></td>
                    <td>Render game</td>
                  </tr>
                  <tr>
                    <td><code>sysRenderUI</code></td>
                    <td>Render user interface</td>
                  </tr>
                  <tr>
                    <td>...</td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
              <h3 id="registering-a-system">
                Registering a System<a
                  class="zola-anchor"
                  href="#registering-a-system"
                  aria-label="Anchor link for: registering-a-system"
                  >#</a
                >
              </h3>
              <p>
                A system is a void function that accepts a
                <code>World</code> instance as its only parameter:
              </p>
              <pre style="background-color: #f6f8f8">
<code><span style="color:#388282;">const </span><span style="color:#555c64;">sysAiEnemy </span><span style="color:#388282;">= </span><span style="color:#555c64;">(</span><span style="color:#8a6c3c;">world</span><span style="color:#388282;">: </span><span style="color:#555c64;">World) </span><span style="color:#388282;">=&gt; </span><span style="color:#555c64;">{}
</span></code></pre>
              <p>
                Systems are registered with the world via the options passed to
                <code>createWorld</code>, or the
                <code>world.addSystem</code> method.
              </p>
              <pre style="background-color: #f6f8f8">
<code><span style="color:#388282;">const </span><span style="color:#555c64;">sysPhysics </span><span style="color:#388282;">= </span><span style="color:#555c64;">() </span><span style="color:#388282;">=&gt; ...
const </span><span style="color:#555c64;">sysRender </span><span style="color:#388282;">= </span><span style="color:#555c64;">() </span><span style="color:#388282;">=&gt; ...
const </span><span style="color:#555c64;">world </span><span style="color:#388282;">= </span><span style="color:#555c64;">createWorld({ systems: [sysPhysics] })

world.addSystem(sysRender)
</span></code></pre>
              <p>
                When <code>world.step()</code> is called, each system is
                executed in the order that it was registered.
              </p>
              <p>
                Systems have a signature of
                <code>(world: World&lt;T&gt;) =&gt; void</code>, where the first
                argument is the world that is currently mid-tick. A single value
                can be passed to <code>world.step(data)</code>, which is then
                available in each system via
                <code>world.state.currentTickData</code>. Often times this value
                holds the amount of time that has elapsed since the previous
                tick, but it can be any value.
              </p>
              <p>
                The following is a world that will log the time elapsed since
                the last tick at around 60Hz:
              </p>
              <pre style="background-color: #f6f8f8">
<code><span style="color:#388282;">const </span><span style="color:#555c64;">world </span><span style="color:#388282;">= </span><span style="color:#555c64;">createWorld&lt;</span><span style="color:#88669e;">number</span><span style="color:#555c64;">&gt;({
  systems: [</span><span style="color:#8a6c3c;">world </span><span style="color:#388282;">=&gt; </span><span style="color:#88669e;">console</span><span style="color:#555c64;">.log(world.state.currentTickData)],
})

</span><span style="color:#388282;">let </span><span style="color:#555c64;">previousTime </span><span style="color:#388282;">= </span><span style="color:#88669e;">Date</span><span style="color:#555c64;">.now()

setInterval(() </span><span style="color:#388282;">=&gt; </span><span style="color:#555c64;">{
  </span><span style="color:#388282;">const </span><span style="color:#555c64;">currentTime </span><span style="color:#388282;">= </span><span style="color:#88669e;">Date</span><span style="color:#555c64;">.now()
  </span><span style="color:#388282;">const </span><span style="color:#555c64;">delta </span><span style="color:#388282;">= </span><span style="color:#555c64;">currentTime </span><span style="color:#388282;">- </span><span style="color:#555c64;">previousTime

  world.step(delta)

  previousTime </span><span style="color:#388282;">= </span><span style="color:#555c64;">currentTime
}, </span><span style="color:#4179ad;">1000 </span><span style="color:#388282;">/ </span><span style="color:#4179ad;">60</span><span style="color:#555c64;">)
</span></code></pre>
              <pre style="background-color: #f6f8f8">
<code><span style="color:#555c64;">&gt; 16.66666666
&gt; 16.66666666
&gt; 16.66666666
</span></code></pre>
              <aside>
                <p>
                  <strong>Tip</strong> — maintaining state using tick
                  <code>data</code> is comparable to using global variables.
                  Consider moving this state into a singleton component. Or, if
                  you need inter-system communication, you can pass messages
                  using topics, which are discussed in the
                  <a href="/ecs/topics">Topics</a> section.
                </p>
              </aside>
              <h2 id="querying-and-iteration">
                Querying and Iteration<a
                  class="zola-anchor"
                  href="#querying-and-iteration"
                  aria-label="Anchor link for: querying-and-iteration"
                  >#</a
                >
              </h2>
              <p>
                Systems query collections of entities and operate on their data
                to yield the next game state. These iterable collections are
                created using <strong>queries</strong> that specify a set of
                component types to query.
              </p>
              <p>
                Depending on its archetype, an entity may be eligible for
                iteration by a system one tick, and ineligible the next. This is
                the cornerstone of ECS: modifying component makeup also modifies
                game behavior. In addition, the isolation of game logic into
                systems makes your game world easier to debug and provides a
                clear target for performance and unit tests.
              </p>
              <p>
                Queries are created with the <code>query</code> function, which
                takes a <strong>selector</strong> of component types.
              </p>
              <pre style="background-color: #f6f8f8">
<code><span style="color:#388282;">import </span><span style="color:#555c64;">{ query } </span><span style="color:#388282;">from </span><span style="color:#4179ad;">&quot;@javelin/ecs&quot;

</span><span style="color:#388282;">const </span><span style="color:#555c64;">players </span><span style="color:#388282;">= </span><span style="color:#555c64;">createQuery(</span><span style="color:#88669e;">Position</span><span style="color:#555c64;">, Velocity)
</span></code></pre>
              <p>
                A query is an iterable object that produces tuples of
                <code>(entity, Component[])</code> for entities that meet the
                selector's criteria.
              </p>
              <p>
                There are two ways to iterate a query. The first (and fastest)
                way is to iterate the query directly with a
                <code>for..of</code> loop:
              </p>
              <pre style="background-color: #f6f8f8">
<code><span style="color:#388282;">for </span><span style="color:#555c64;">(</span><span style="color:#388282;">const </span><span style="color:#555c64;">[entities, [position, velocity]] </span><span style="color:#388282;">of </span><span style="color:#555c64;">players) {
  </span><span style="color:#388282;">for </span><span style="color:#555c64;">(</span><span style="color:#388282;">let </span><span style="color:#555c64;">i </span><span style="color:#388282;">= </span><span style="color:#4179ad;">0</span><span style="color:#555c64;">; i </span><span style="color:#388282;">&lt; </span><span style="color:#555c64;">entities.length; i</span><span style="color:#388282;">++</span><span style="color:#555c64;">) {
    position[i].x </span><span style="color:#388282;">+= </span><span style="color:#555c64;">velocity[i].x
    position[i].y </span><span style="color:#388282;">+= </span><span style="color:#555c64;">velocity[i].y
  }
}
</span></code></pre>
              <p>
                This method of iteration leaks the implementation details of how
                components are stored in archetypes. An outer
                <code>for..of</code> loop iterates through each matching
                archetype, while an inner loop accesses components for each
                matching entity. If your game doesn't reach high entity counts
                (10^5) and you don't mind a 2-3x iteration performance hit,
                consider using <code>forEach</code>. This method executes a
                callback for each entity that matches the query:
              </p>
              <pre style="background-color: #f6f8f8">
<code><span style="color:#555c64;">players.forEach((</span><span style="color:#8a6c3c;">entity</span><span style="color:#555c64;">, [</span><span style="color:#8a6c3c;">position</span><span style="color:#555c64;">, </span><span style="color:#8a6c3c;">velocity</span><span style="color:#555c64;">]) </span><span style="color:#388282;">=&gt; </span><span style="color:#555c64;">{
  position.x </span><span style="color:#388282;">+= </span><span style="color:#555c64;">velocity.x
  position.y </span><span style="color:#388282;">+= </span><span style="color:#555c64;">velocity.y
})
</span></code></pre>
              <aside>
                <p>
                  <strong>Tip</strong> — most examples in the Javelin docs use
                  <code>forEach</code> since it's a bit easier to read, but
                  stick to the <code>for..of</code> approach if your game has
                  many entities.
                </p>
              </aside>
              <p>
                The order of component types in the query's selector will match
                the order of components in the query's results. That is,
                <code>createQuery(Position, Player)</code> will always yield
                tuples of components <code>(Position, Player)</code>:
              </p>
              <pre style="background-color: #f6f8f8">
<code><span style="color:#555c64;">world.create(world.component(Player), world.component(</span><span style="color:#88669e;">Position</span><span style="color:#555c64;">))
world.create(world.component(</span><span style="color:#88669e;">Position</span><span style="color:#555c64;">), world.component(Player))

</span><span style="color:#388282;">const </span><span style="color:#555c64;">sysRender </span><span style="color:#388282;">= </span><span style="color:#555c64;">() </span><span style="color:#388282;">=&gt; </span><span style="color:#555c64;">{
  players.forEach((</span><span style="color:#8a6c3c;">entity</span><span style="color:#555c64;">, [</span><span style="color:#8a6c3c;">position</span><span style="color:#555c64;">, </span><span style="color:#8a6c3c;">player</span><span style="color:#555c64;">]) </span><span style="color:#388282;">=&gt; </span><span style="color:#555c64;">{
    </span><span style="color:#8c95a0;">// render each player with a name tag
    </span><span style="color:#555c64;">draw(sprites.player, position, player.name)
  })
}
</span></code></pre>
              <h3 id="query-caveats">
                Query Caveats<a
                  class="zola-anchor"
                  href="#query-caveats"
                  aria-label="Anchor link for: query-caveats"
                  >#</a
                >
              </h3>
              <p>
                The tuple of components yielded by queries is re-used each
                iteration. This means that you shouldn't store the results of a
                query for use later like this:
              </p>
              <pre style="background-color: #f6f8f8">
<code><span style="color:#388282;">const </span><span style="color:#555c64;">sysStatusEffects </span><span style="color:#388282;">= </span><span style="color:#555c64;">() </span><span style="color:#388282;">=&gt; </span><span style="color:#555c64;">{
  </span><span style="color:#388282;">const </span><span style="color:#555c64;">results </span><span style="color:#388282;">= </span><span style="color:#555c64;">[]
  shocked.forEach((</span><span style="color:#8a6c3c;">e</span><span style="color:#555c64;">, </span><span style="color:#8a6c3c;">components</span><span style="color:#555c64;">) </span><span style="color:#388282;">=&gt; </span><span style="color:#555c64;">{
    results.push(components)
  })
  </span><span style="color:#388282;">...
</span><span style="color:#555c64;">}
</span></code></pre>
              <p>
                Every index of <code>results</code> corresponds to the same
                array, which is the tuple of components attached to the entity
                of the last iteration. If you absolutely need to store
                components between queries (e.g. you are optimizing a nested
                query), you could push the components of interest into a
                temporary array, e.g.
              </p>
              <pre style="background-color: #f6f8f8">
<code><span style="color:#388282;">const </span><span style="color:#555c64;">results </span><span style="color:#388282;">= </span><span style="color:#555c64;">[]
shocked.forEach((</span><span style="color:#8a6c3c;">e</span><span style="color:#555c64;">, [</span><span style="color:#8a6c3c;">a</span><span style="color:#555c64;">, </span><span style="color:#8a6c3c;">b</span><span style="color:#555c64;">]) </span><span style="color:#388282;">=&gt; </span><span style="color:#555c64;">{
  results.push([a, b])
})
</span></code></pre>
            </div>
          </div>
        </div>
      </section>
    </main>
  </body>
</html>
